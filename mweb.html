<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	mweb - wjw'blog
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="wjw'blog" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
					
					<h1><a href="index.html">wjw'blog</a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">













								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-09-26T08:06:29+08:00" itemprop="datePublished">2018/9/26</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='mweb.html'>mweb</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15379203897873.html" itemprop="url">
		Dart语言2.0学习</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ul>
<li>
<a href="#toc_0">疑惑</a>
</li>
<li>
<a href="#toc_1">尝试</a>
<ul>
<li>
<a href="#toc_2">第一个程序</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">重要概念</a>
</li>
<li>
<a href="#toc_4">关键字</a>
</li>
<li>
<a href="#toc_5">变量</a>
</li>
<li>
<a href="#toc_6">默认值</a>
</li>
<li>
<a href="#toc_7">常数</a>
</li>
<li>
<a href="#toc_8">内置类型</a>
<ul>
<li>
<a href="#toc_9">Numbers</a>
<ul>
<li>
<a href="#toc_10">int</a>
</li>
<li>
<a href="#toc_11">double</a>
</li>
</ul>
</li>
<li>
<a href="#toc_12">Strings</a>
</li>
<li>
<a href="#toc_13">Booleans</a>
</li>
<li>
<a href="#toc_14">Lists</a>
</li>
<li>
<a href="#toc_15">Maps</a>
</li>
<li>
<a href="#toc_16">Runes</a>
</li>
<li>
<a href="#toc_17">Symbols</a>
</li>
</ul>
</li>
<li>
<a href="#toc_18">Functions</a>
<ul>
<li>
<a href="#toc_19">可选参数</a>
<ul>
<li>
<a href="#toc_20">可选命名参数</a>
</li>
<li>
<a href="#toc_21">可选位置参数</a>
</li>
</ul>
</li>
<li>
<a href="#toc_22">参数默认值</a>
</li>
</ul>
</li>
<li>
<a href="#toc_23">main()函数</a>
<ul>
<li>
<a href="#toc_24">函数作为第一类对象</a>
</li>
<li>
<a href="#toc_25">匿名函数</a>
</li>
<li>
<a href="#toc_26">闭包</a>
</li>
<li>
<a href="#toc_27">测试函数是否相等</a>
</li>
<li>
<a href="#toc_28">返回值</a>
</li>
</ul>
</li>
<li>
<a href="#toc_29">运算符</a>
<ul>
<li>
<a href="#toc_30">算术运算符</a>
</li>
<li>
<a href="#toc_31">相等和关系运算符</a>
</li>
<li>
<a href="#toc_32">类型测试运算符</a>
</li>
<li>
<a href="#toc_33">赋值运算符</a>
</li>
<li>
<a href="#toc_34">逻辑运算符</a>
</li>
<li>
<a href="#toc_35">按位和移位运算符</a>
</li>
<li>
<a href="#toc_36">条件表达式</a>
</li>
<li>
<a href="#toc_37">级联符号(..)</a>
</li>
<li>
<a href="#toc_38">其他运算符</a>
</li>
</ul>
</li>
<li>
<a href="#toc_39">控制流程语句</a>
<ul>
<li>
<a href="#toc_40">if and else</a>
</li>
<li>
<a href="#toc_41">For loops</a>
</li>
<li>
<a href="#toc_42">While and do-while</a>
</li>
<li>
<a href="#toc_43">Break and continue</a>
</li>
<li>
<a href="#toc_44">Switch and case</a>
</li>
<li>
<a href="#toc_45">Assert</a>
</li>
</ul>
</li>
<li>
<a href="#toc_46">Exceptions</a>
<ul>
<li>
<a href="#toc_47">Throw</a>
</li>
<li>
<a href="#toc_48">Catch</a>
</li>
<li>
<a href="#toc_49">Finally</a>
</li>
</ul>
</li>
<li>
<a href="#toc_50">Classes</a>
<ul>
<li>
<a href="#toc_51">适用类成员</a>
</li>
<li>
<a href="#toc_52">使用构造函数</a>
</li>
<li>
<a href="#toc_53">获取对象的类型</a>
</li>
<li>
<a href="#toc_54">实例变量</a>
</li>
<li>
<a href="#toc_55">构造函数</a>
<ul>
<li>
<a href="#toc_56">默认构造函数</a>
</li>
<li>
<a href="#toc_57">构造函数会被继承</a>
</li>
<li>
<a href="#toc_58">命名构造函数</a>
</li>
<li>
<a href="#toc_59">调用非默认的超类构造函数</a>
<ul>
<li>
<a href="#toc_60">初始化列表</a>
</li>
</ul>
</li>
<li>
<a href="#toc_61">重定向构造函数</a>
</li>
<li>
<a href="#toc_62">常量构造函数</a>
</li>
<li>
<a href="#toc_63">工厂构造函数</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_64">Methods</a>
<ul>
<li>
<a href="#toc_65">实例方法</a>
</li>
<li>
<a href="#toc_66">Getters and setters</a>
</li>
<li>
<a href="#toc_67">抽象方法</a>
</li>
</ul>
</li>
<li>
<a href="#toc_68">抽象类</a>
</li>
<li>
<a href="#toc_69">隐式接口</a>
</li>
<li>
<a href="#toc_70">Extending a class</a>
<ul>
<li>
<a href="#toc_71">重写(覆盖)成员</a>
</li>
<li>
<a href="#toc_72">可覆盖操作符</a>
</li>
<li>
<a href="#toc_73">noSuchMethod()</a>
</li>
</ul>
</li>
<li>
<a href="#toc_74">枚举类型</a>
<ul>
<li>
<a href="#toc_75">使用枚举</a>
</li>
<li>
<a href="#toc_76">向类添加功能：mixins</a>
</li>
<li>
<a href="#toc_77">Class variables and methods</a>
<ul>
<li>
<a href="#toc_78">静态变量</a>
</li>
<li>
<a href="#toc_79">静态方法</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_80">泛型</a>
<ul>
<li>
<a href="#toc_81">为什么要使用泛型？</a>
</li>
<li>
<a href="#toc_82">Using collection literals</a>
</li>
<li>
<a href="#toc_83">使用带有构造函数的参数化类型</a>
</li>
<li>
<a href="#toc_84">泛型集合及其包含的类型</a>
</li>
<li>
<a href="#toc_85">限制参数化类型</a>
</li>
<li>
<a href="#toc_86">使用泛型方法</a>
</li>
</ul>
</li>
<li>
<a href="#toc_87">Libraries and visibility</a>
<ul>
<li>
<a href="#toc_88">使用库</a>
</li>
<li>
<a href="#toc_89">指定库前缀</a>
</li>
<li>
<a href="#toc_90">仅导入库的一部分</a>
</li>
<li>
<a href="#toc_91">懒加载一个库</a>
</li>
<li>
<a href="#toc_92">实现库</a>
</li>
</ul>
</li>
<li>
<a href="#toc_93">异步支持</a>
<ul>
<li>
<a href="#toc_94">Handling Futures(处理期货)</a>
</li>
<li>
<a href="#toc_95">声明异步函数</a>
</li>
<li>
<a href="#toc_96">处理流</a>
</li>
</ul>
</li>
<li>
<a href="#toc_97">生成器</a>
</li>
<li>
<a href="#toc_98">Callable classes</a>
</li>
<li>
<a href="#toc_99">隔离</a>
</li>
<li>
<a href="#toc_100">类型定义</a>
</li>
<li>
<a href="#toc_101">元数据</a>
</li>
<li>
<a href="#toc_102">注释</a>
<ul>
<li>
<a href="#toc_103">单行注释</a>
</li>
<li>
<a href="#toc_104">多行注释</a>
</li>
<li>
<a href="#toc_105">文档注释</a>
</li>
</ul>
</li>
<li>
<a href="#toc_106">总结</a>
</li>
</ul>


<h2 id="toc_0">疑惑</h2>

<ul>
<li class="task-list-item"><input disabled="disabled" type="checkbox" /> const和final
</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" /> Symbols
</li>
</ul>

<h2 id="toc_1">尝试</h2>

<h3 id="toc_2">第一个程序</h3>

<pre><code class="language-Dart">// 定义一个函数
printInteger(int teg){
  print(&#39;the number is $teg.&#39;);
}
// 主函数
main(){
  // 定义变量
  var number = 24;
  // 调用函数
    printInteger(24);
}
</code></pre>

<ul>
<li>函数的定义</li>
<li>函数的调用</li>
<li>变量的定义</li>
<li>主函数</li>
<li>每一行代码以&quot;;&quot;结束</li>
<li>字符串以单引号或者双引号定义</li>
<li>字符串内直接引用变量替换以&quot;$&quot;开头然后</li>
<li>单行注释的写法</li>
<li>print函数</li>
</ul>

<h2 id="toc_3">重要概念</h2>

<ul>
<li>所有可放入变量的内容都是对象,所有对象都是某个类的实例.甚至数值,函数和null.所有对象都继承自object类.</li>
<li>Dart是强类型语言,类型生命仍然是可选的,因为dart可以推断类型.在上面的代码中number变量被推断为int类型.如果不想用推断类型,可以用动态类型dynamic.</li>
<li>Dart支持泛型,如List<int>(整数列表)或者List<dynamic>(任何类型的对象列表).</li>
<li>Dart支持顶级函数（例如main（）），以及绑定到类或对象的函数（分别是静态和实例方法）。您还可以在函数内创建函数（嵌套函数或本地函数）。</li>
<li>类似地，Dart支持顶级变量，以及绑定到类或对象的变量（静态和实例变量）。实例变量有时称为字段或属性。</li>
<li>与Java不同，Dart没有关键字public，protected和private。如果标识符以下划线（_）开头，则它对其库是私有的。有关详细信息，请参阅库和可见性。</li>
<li>标识符可以以字母或下划线（_）开头，后跟这些字符加数字的任意组合。</li>
<li>Dart同时有表达式（具有运行时值）和语句（不具有运行时值）。例如，条件表达式<code>条件 ? expr1：expr2</code>的值为expr1或expr2。将其与if-else语句进行比较，该语句没有任何值。语句通常包含一个或多个表达式，但表达式不能直接包含语句。</li>
<li>Dart工具可以报告两种问题：警告和错误。警告只是表明您的代码可能无法正常工作，但它们不会阻止您的程序执行。错误可以是编译时或运行时。编译时错误会阻止代码执行;运行时错误导致代码执行时引发异常。</li>
</ul>

<h2 id="toc_4">关键字</h2>

<p>下表列出了Dart语言专门处理的单词。</p>

<table>
<thead>
<tr>
<th>abstract <sup>2</sup></th>
<th>dynamic <sup>2</sup></th>
<th>implements <sup>2</sup></th>
<th>show <sup>1</sup></th>
</tr>
</thead>

<tbody>
<tr>
<td>as <sup>2</sup></td>
<td>else</td>
<td>import <sup>2</sup></td>
<td>static <sup>2</sup></td>
</tr>
<tr>
<td>assert</td>
<td>enum</td>
<td>in</td>
<td>super</td>
</tr>
<tr>
<td>async <sup>1</sup></td>
<td>export <sup>2</sup></td>
<td>interface <sup>2</sup></td>
<td>switch</td>
</tr>
<tr>
<td>await <sup>3</sup></td>
<td>external <sup>2</sup></td>
<td>is</td>
<td>sync <sup>1</sup></td>
</tr>
<tr>
<td>break</td>
<td>extends</td>
<td>library <sup>2</sup></td>
<td>this</td>
</tr>
<tr>
<td>case</td>
<td>factory <sup>2</sup></td>
<td>mixin <sup>2</sup></td>
<td>throw</td>
</tr>
<tr>
<td>catch</td>
<td>false</td>
<td>new</td>
<td>true</td>
</tr>
<tr>
<td>class</td>
<td>final</td>
<td>null</td>
<td>try</td>
</tr>
<tr>
<td>const</td>
<td>finally</td>
<td>on <sup>1</sup></td>
<td>typedef <sup>2</sup></td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>operator <sup>2</sup></td>
<td>var</td>
</tr>
<tr>
<td>covariant <sup>2</sup></td>
<td>Function <sup>2</sup></td>
<td>part <sup>2</sup></td>
<td>void</td>
</tr>
<tr>
<td>default</td>
<td>get <sup>2</sup></td>
<td>rethrow</td>
<td>while</td>
</tr>
<tr>
<td>deferred <sup>2</sup></td>
<td>hide <sup>1</sup></td>
<td>return</td>
<td>with</td>
</tr>
<tr>
<td>do</td>
<td>if</td>
<td>set <sup>2</sup></td>
<td>yield <sup>3</sup></td>
</tr>
</tbody>
</table>

<p>避免使用这些单词作为标识符。但是，如有必要，标有上标的关键字可以是标识符：</p>

<ul>
<li>带有上标1的单词是上下文关键字，仅在特定位置具有含义。他们在任何位置都是有效的标识符。</li>
<li>带有上标2的单词是内置标识符。为了简化将JavaScript代码移植到Dart的任务，这些关键字在大多数地方都是有效的标识符，但它们不能用作类或类型名称，也不能用作导入前缀。</li>
<li>带有上标3的单词是与Dart 1.0发布后添加的异步支持相关的更新，有限的保留字。您不能在标记为async，async *或sync *的任何函数体中使用await或yield作为标识符。</li>
</ul>

<p>表中的所有其他单词都是保留字，不能是标识符。</p>

<h2 id="toc_5">变量</h2>

<p>这是创建变量并初始化它的示例：</p>

<pre><code class="language-Dart">var name = &#39;Bob&#39;;
</code></pre>

<p>变量存储引用。名为name的变量包含对String对象的引用，其值为“Bob”。</p>

<p>name变量的类型被推断为String，但您可以通过指定它来更改该类型。如果对象不限于单个类型，请按照设计准则指定对象或动态类型。<br/>
<code>Dart<br/>
dynamic name = &#39;Bob&#39;;<br/>
</code><br/>
另一种选择是显式声明可以推断出的类型：<br/>
<code>Dart<br/>
String name = &#39;Bob&#39;;<br/>
</code></p>

<blockquote>
<p>注意：此页面遵循为局部变量使用var而不是类型注释的样式指南建议。</p>
</blockquote>

<h2 id="toc_6">默认值</h2>

<p>未初始化的变量的初始值为null。即使是具有数字类型的变量最初也是null，因为数字 - 就像Dart中的其他所有 - 都是对象。<br/>
<code>Dart<br/>
int lineCount;<br/>
assert(lineCount == null);<br/>
</code></p>

<blockquote>
<p>注意：生产代码中将忽略assert（）调用。在开发期间，断言（条件）抛出异常，除非条件为真。有关详细信息，请参阅断言。</p>
</blockquote>

<h2 id="toc_7">常数</h2>

<p>如果您从不打算更改变量，请使用final或const，而不是var或类型。最终变量只能设置一次; const变量是编译时常量。 （Const变量是隐式最终的。）最终的顶级或类变量在第一次使用时被初始化。</p>

<blockquote>
<p>注意：实例成员变量可以是final，但不是const。必须在构造函数启动之前初始化最终实例变量 - 在变量声明时，构造函数参数或构造函数的初始化列表中。</p>
</blockquote>

<p>以下是创建和设置最终变量的示例：</p>

<pre><code class="language-Dart">final name = &#39;Bob&#39;; // 没有类型注释
final String nickname = &#39;Bobby&#39;;
</code></pre>

<p>您无法更改最终变量的值：</p>

<pre><code class="language-Dart">name = &#39;Alice&#39;; // Error: a final variable can only be set once.
</code></pre>

<p>对于要成为编译时常量的变量，请使用const。如果const变量在类级别，则将其标记为static const。在声明变量的地方，将值设置为编译时常量，例如数字或字符串文字，const变量或常数上的算术运算结果：</p>

<pre><code class="language-Dart">const bar = 1000000; // Unit of pressure (dynes/cm2)
const double atm = 1.01325 * bar; // Standard atmosphere
</code></pre>

<p>const关键字不只是用于声明常量变量。您还可以使用它来创建常量值，以及声明创建常量值的构造函数。任何变量都可以具有常量值。</p>

<pre><code class="language-Dart">var foo = const [];
final bar = const [];
const baz = []; // 相当于 `const []`
</code></pre>

<p>你可以从const声明的初始化表达式中省略const，就像上面的baz一样。有关详细信息，请参阅不要冗余地使用const。</p>

<p>您可以更改非final，非const变量的值，即使它曾经有一个const值：</p>

<pre><code class="language-Dart">foo = [1, 2, 3]; // 曾经是 const []
</code></pre>

<p>您无法更改const变量的值：</p>

<pre><code class="language-Dart">baz = [42]; // Error: Constant variables can&#39;t be assigned a value.
</code></pre>

<p>有关使用const创建常量值的更多信息，请参阅List，Maps和Classes。</p>

<h2 id="toc_8">内置类型</h2>

<p>Dart语言特别支持以下类型：</p>

<ul>
<li>numbers</li>
<li>strings</li>
<li>booleans</li>
<li>lists (also known as arrays)</li>
<li>maps</li>
<li>runes (用于表示字符串中的Unicode字符 )</li>
<li>symbols</li>
</ul>

<p>您可以使用文字初始化任何这些特殊类型的对象。例如，&#39;this is a string&#39;是一个字符串文字，true是一个布尔文字。</p>

<p>因为Dart中的每个变量都引用一个对象 - 一个类的实例 - 您通常可以使用构造函数来初始化变量。一些内置类型有自己的构造函数。例如，您可以使用<code>Map()</code>构造函数来创建map。</p>

<h3 id="toc_9">Numbers</h3>

<p>Dart中数字有两种形式：</p>

<h4 id="toc_10">int</h4>

<p>整数值不大于64位，具体取决于平台。在Dart VM上，值可以是-263到263 - 1.编译为JavaScript的Dart使用JavaScript编号，允许从-253到253 - 1的值。</p>

<h4 id="toc_11">double</h4>

<p>64位（双精度）浮点数，由IEEE 754标准规定。</p>

<p>int和double都是num的子类型。 num类型包括基本运算符，如+， - ，/和*，也是你可以找到abs（），ceil（）和floor（）以及其他方法的地方。 （按位运算符，如&gt;&gt;，在int类中定义。）如果num及其子类型没有您要查找的内容，则dart：math库中可能有。</p>

<p>整数是没有小数点的数字。以下是定义整数文字的一些示例：</p>

<pre><code class="language-Dart">int x = 1;
int hex = 0xDEADBEEF;
</code></pre>

<p>如果数字包含小数，则为双精度数。以下是定义双重文字的一些示例：</p>

<pre><code class="language-Dart">double y = 1.1;
double exponents = 1.42e5;
</code></pre>

<p>以下是将字符串转换为数字的方法，反之亦然：</p>

<pre><code class="language-Dart">// String -&gt; int
var one = int.parse(&#39;1&#39;);
assert(one == 1);

// String -&gt; double
var onePointOne = double.parse(&#39;1.1&#39;);
assert(onePointOne == 1.1);

// int -&gt; String
String oneAsString = 1.toString();
assert(oneAsString == &#39;1&#39;);

// double -&gt; String
String piAsString = 3.14159.toStringAsFixed(2);
assert(piAsString == &#39;3.14&#39;);
</code></pre>

<p>int类型支持传统的位运算（&lt;&lt;，&gt;&gt;），AND（＆）和OR（|）运算符。例如：</p>

<pre><code class="language-Dart">assert((3 &lt;&lt; 1) == 6); // 0011 &lt;&lt; 1 == 0110
assert((3 &gt;&gt; 1) == 1); // 0011 &gt;&gt; 1 == 0001
assert((3 | 4) == 7); // 0011 | 0100 == 0111
</code></pre>

<p>文字数字是编译时常量。许多算术表达式也是编译时常量，只要它们的操作数是编译为数字的编译时常量。</p>

<pre><code class="language-Dart">const msPerSecond = 1000;
const secondsUntilRetry = 5;
const msUntilRetry = secondsUntilRetry * msPerSecond;
</code></pre>

<h3 id="toc_12">Strings</h3>

<p>Dart字符串是一系列UTF-16代码单元。您可以使用单引号或双引号来创建字符串：</p>

<pre><code class="language-Dart">var s1 = &#39;Single quotes work well for string literals.&#39;;
var s2 = &quot;Double quotes work just as well.&quot;;
var s3 = &#39;It\&#39;s easy to escape the string delimiter.&#39;;
var s4 = &quot;It&#39;s even easier to use the other delimiter.&quot;;
</code></pre>

<p>您可以使用$ {expression}将表达式的值放在字符串中。如果表达式是标识符，则可以跳过{}。要获取对应于对象的字符串，Dart调用对象的toString（）方法。</p>

<pre><code class="language-Dart">var s = &#39;string interpolation&#39;;

assert(&#39;Dart has $s, which is very handy.&#39; ==
    &#39;Dart has string interpolation, &#39; +
        &#39;which is very handy.&#39;);
assert(&#39;That deserves all caps. &#39; +
        &#39;${s.toUpperCase()} is very handy!&#39; ==
    &#39;That deserves all caps. &#39; +
        &#39;STRING INTERPOLATION is very handy!&#39;);
</code></pre>

<blockquote>
<p>注意：==运算符测试两个对象是否相同。如果两个字符串包含相同的代码单元序列，则它们是等效的。</p>
</blockquote>

<p>您可以使用相邻的字符串文字或+运算符来连接字符串：</p>

<pre><code class="language-Dart">var s1 = &#39;String &#39;
    &#39;concatenation&#39;
    &quot; works even over line breaks.&quot;;
assert(s1 ==
    &#39;String concatenation works even over &#39;
    &#39;line breaks.&#39;);

var s2 = &#39;The + operator &#39; + &#39;works, as well.&#39;;
assert(s2 == &#39;The + operator works, as well.&#39;);
</code></pre>

<p>创建多行字符串的另一种方法：使用带有单引号或双引号的三重引号：</p>

<pre><code class="language-Dart">var s1 = &#39;&#39;&#39;
You can create
multi-line strings like this one.
&#39;&#39;&#39;;

var s2 = &quot;&quot;&quot;This is also a
multi-line string.&quot;&quot;&quot;;
</code></pre>

<p>您可以通过在其前面加上r来创建“raw”字符串：</p>

<pre><code class="language-Dart">var s = r&#39;In a raw string, not even \n gets special treatment.&#39;;
</code></pre>

<p>有关如何在字符串中表示Unicode字符的详细信息，请参阅Runes。</p>

<p>文字字符串是编译时常量，只要任何插值表达式是一个编译时常量，其值为null或数值，字符串或布尔值。</p>

<pre><code class="language-Dart">// These work in a const string.
const aConstNum = 0;
const aConstBool = true;
const aConstString = &#39;a constant string&#39;;

// These do NOT work in a const string.
var aNum = 0;
var aBool = true;
var aString = &#39;a string&#39;;
const aConstList = [1, 2, 3];

const validConstString = &#39;$aConstNum $aConstBool $aConstString&#39;;
// const invalidConstString = &#39;$aNum $aBool $aString $aConstList&#39;;
</code></pre>

<p>有关使用字符串的更多信息，请参阅字符串和正则表达式。</p>

<h3 id="toc_13">Booleans</h3>

<p>为了表示布尔值，Dart有一个名为bool的类型。只有两个对象具有bool类型：boolean literals true和false，它们都是编译时常量。</p>

<p>Dart的类型安全意味着您不能使用if（nonbooleanValue）或assert（nonbooleanValue）等代码。相反，明确检查值，如下所示：</p>

<pre><code class="language-Dart">// Check for an empty string.
var fullName = &#39;&#39;;
assert(fullName.isEmpty);

// Check for zero.
var hitPoints = 0;
assert(hitPoints &lt;= 0);

// Check for null.
var unicorn;
assert(unicorn == null);

// Check for NaN.
var iMeantToDoThis = 0 / 0;
assert(iMeantToDoThis.isNaN);
</code></pre>

<h3 id="toc_14">Lists</h3>

<p>也许几乎每种编程语言中最常见的集合是数组或有序的对象组。在Dart中，数组是List对象，因此大多数人只是将它们称为列表。</p>

<p>Dart列表文字看起来像JavaScript数组文字。这是一个简单的Dart列表：</p>

<pre><code class="language-Dart">var list = [1, 2, 3];
</code></pre>

<blockquote>
<p>注意：分析器推断列表的类型为List <int>。如果尝试将非整数对象添加到此列表，则分析器或运行时会引发错误。有关更多信息，请阅读类型推断。</p>
</blockquote>

<p>列表使用从零开始的索引，其中0是第一个元素的索引，<code>list.length - 1</code>是最后一个元素的索引。您可以像在JavaScript中一样获取列表的长度并引用列表元素：</p>

<pre><code class="language-Dart">var list = [1, 2, 3];
assert(list.length == 3);
assert(list[1] == 2);

list[1] = 1;
assert(list[1] == 1);
</code></pre>

<p>要创建一个编译时常量的列表，请在列表文字之前添加const：</p>

<pre><code class="language-Dart">var constantList = const [1, 2, 3];
// constantList[1] = 1; // Uncommenting this causes an error.
</code></pre>

<p>List类型有许多方便的方法来操作列表。有关列表的更多信息，请参阅泛型和集合。</p>

<h3 id="toc_15">Maps</h3>

<p>通常，映射是关联键和值的对象。键和值都可以是任何类型的对象。每个键只出现一次，但您可以多次使用相同的值。Dart支持由map文字和map类型提供。</p>

<p>这里有几个简单的Dart map，使用map文字创建：</p>

<pre><code class="language-Dart">var gifts = {
  // Key:    Value
  &#39;first&#39;: &#39;partridge&#39;,
  &#39;second&#39;: &#39;turtledoves&#39;,
  &#39;fifth&#39;: &#39;golden rings&#39;
};

var nobleGases = {
  2: &#39;helium&#39;,
  10: &#39;neon&#39;,
  18: &#39;argon&#39;,
};
</code></pre>

<blockquote>
<p>注意：分析器推断<code>gifts</code>的类型为Map <String，String>，而<code>nobleGases</code>的类型为Map <int，String>。如果您尝试将错误类型的值添加到任一映射，则分析器或运行时会引发错误。有关更多信息，请阅读类型推断。</p>
</blockquote>

<p>您可以使用Map构造函数创建相同的对象：</p>

<pre><code class="language-Dart">var gifts = Map();
gifts[&#39;first&#39;] = &#39;partridge&#39;;
gifts[&#39;second&#39;] = &#39;turtledoves&#39;;
gifts[&#39;fifth&#39;] = &#39;golden rings&#39;;

var nobleGases = Map();
nobleGases[2] = &#39;helium&#39;;
nobleGases[10] = &#39;neon&#39;;
nobleGases[18] = &#39;argon&#39;;
</code></pre>

<blockquote>
<p>注意：您可能希望看到<code>new Map()</code>而不仅仅是<code>Map()</code>。从Dart 2开始，new关键字是可选的。有关详细信息，请参阅使用构造函数.</p>
</blockquote>

<p>像在JavaScript中一样，将新的键值对添加到现有map：</p>

<pre><code class="language-Dart">var gifts = {&#39;first&#39;: &#39;partridge&#39;};
gifts[&#39;fourth&#39;] = &#39;calling birds&#39;; // Add a key-value pair
</code></pre>

<p>以与在JavaScript中相同的方式从map中检索值：</p>

<pre><code class="language-Dart">var gifts = {&#39;first&#39;: &#39;partridge&#39;};
assert(gifts[&#39;first&#39;] == &#39;partridge&#39;);
</code></pre>

<p>如果您查找不在map中的键，则返回null：</p>

<pre><code class="language-Dart">var gifts = {&#39;first&#39;: &#39;partridge&#39;};
assert(gifts[&#39;fifth&#39;] == null);
</code></pre>

<p>使用<code>.length</code>来获取map中键值对的数量：</p>

<pre><code class="language-Dart">final constantMap = const {
  2: &#39;helium&#39;,
  10: &#39;neon&#39;,
  18: &#39;argon&#39;,
};

// constantMap[2] = &#39;Helium&#39;; // Uncommenting this causes an error.
</code></pre>

<p>有关地图的更多信息，请参阅泛型和maps。</p>

<h3 id="toc_16">Runes</h3>

<p>在Dart中，Runes是字符串的UTF-32编码。</p>

<p>Unicode为世界上所有书写系统中使用的每个字母，数字和符号定义唯一的数值。由于Dart字符串是一系列UTF-16代码单元，因此在字符串中表示32位Unicode值需要特殊语法。</p>

<p>表达Unicode代码点的常用方法是<code>\uXXXX</code>，其中XXXX是4位十六进制值。例如，心脏符号（♥）是<code>\u2665</code>。要指定多于或少于4个十六进制数字，请将值放在大括号中。例如，笑的表情符号（😆）是<code>\u{1f600}</code>。</p>

<p>String类有几个属性可用于提取符文信息。 codeUnitAt和codeUnit属性返回16位代码单元。使用runes属性获取字符串的文本。</p>

<p>以下示例说明了符文，16位代码单元和32位代码点之间的关系。再Dart Pad中单击“运行”按钮以查看运行中的符文。</p>

<pre><code class="language-Dart">main() {
  var clapping = &#39;\u{1f44f}&#39;;
  print(clapping);
  print(clapping.codeUnits);
  print(clapping.runes.toList());

  Runes input = new Runes(
      &#39;\u2665  \u{1f605}  \u{1f60e}  \u{1f47b}  \u{1f596}  \u{1f44d}&#39;);
  print(new String.fromCharCodes(input));
}
</code></pre>

<blockquote>
<p>注意：使用列表操作操作符文时要小心。这种方法很容易分解，具体取决于特定的语言，字符集和操作。有关更多信息，请参阅<a href="http://stackoverflow.com/questions/21521729/how-do-i-reverse-a-string-in-dart">如何在Dart中反转字符串？</a>在Stack Overflow上。</p>
</blockquote>

<h3 id="toc_17">Symbols</h3>

<p>Symbol对象表示在Dart程序中声明的运算符或标识符。您可能永远不需要使用符号，但它们对于按名称引用标识符的API非常有用，因为缩小会更改标识符名称而不会更改标识符符号。</p>

<p>要获取标识符的符号，请使用符号文字，它只是＃后跟标识符：</p>

<pre><code class="language-Dart">#radix
#bar
</code></pre>

<p>符号文字是编译时常量。</p>

<h2 id="toc_18">Functions</h2>

<p>Dart是一种真正的面向对象语言，因此即使是函数也是对象并且具有类型。这意味着函数可以分配给变量或作为参数传递给其他函数。您也可以像调用函数一样调用Dart类的实例。有关详细信息，请参阅可调用类。</p>

<p>以下是实现函数的示例：</p>

<pre><code class="language-Dart">bool isNoble(int atomicNumber) {
  return _nobleGases[atomicNumber] != null;
}
</code></pre>

<p>虽然Effective Dart建议<a href="https://www.dartlang.org/guides/language/effective-dart/design#prefer-type-annotating-public-fields-and-top-level-variables-if-the-type-isnt-obvious">为公共API声明类型</a>，但如果省略类型，该函数仍然有效：</p>

<pre><code class="language-Dart">isNoble(atomicNumber) {
  return _nobleGases[atomicNumber] != null;
}
</code></pre>

<p>对于只包含一个表达式的函数，可以使用简写语法：</p>

<pre><code class="language-Dart">bool isNoble(int atomicNumber) =&gt; _nobleGases[atomicNumber] != null;
</code></pre>

<p><code>=&gt; expr</code>语法是<code>{return expr;}</code>的简写。 <code>=&gt;</code>表示法有时称为<em>arrow syntax</em>。</p>

<blockquote>
<p>注意：箭头（=&gt;）和分号（;）之间只能出现表达式而非语句。例如，您不能在其中放置<a href="https://www.dartlang.org/guides/language/language-tour#if-and-else">if语句</a>，但可以使用<a href="https://www.dartlang.org/guides/language/language-tour#conditional-expressions">条件表达式</a>。</p>
</blockquote>

<p>函数可以有两种类型的参数：必需和可选。首先列出所需参数，然后列出任何可选参数。命名的可选参数也可以标记为@required。有关详细信息，请参阅下一节。</p>

<h3 id="toc_19">可选参数</h3>

<p>可选参数可以是位置参数，也可以是命名参数，但不能同时使用.</p>

<h4 id="toc_20">可选命名参数</h4>

<p>调用函数时，可以使用<code>paramName: value</code>指定命名参数。例如：</p>

<pre><code class="language-Dart">enableFlags(bold: true, hidden: false);
</code></pre>

<p>定义函数时，使用<code>{param1,param2, ...}</code>指定命名参数：</p>

<pre><code class="language-Dart">/// Sets the [bold] and [hidden] flags ...
void enableFlags({bool bold, bool hidden}) {...}
</code></pre>

<p><a href="https://flutter.io/">Flutter</a>实例创建表达式可能变得复杂，因此窗口小部件构造函数仅使用命名参数。这使得实例创建表达式更易于阅读。</p>

<p>您可以使用@required在任何Dart代码（不仅仅是Flutter）中注释命名参数，以指示它是必需参数。例如：</p>

<pre><code class="language-Dart">const Scrollbar({Key key, @required Widget child})
</code></pre>

<p>构建Scrollbar时，分析器会在<code>child</code>参数不存在时报告问题。</p>

<p><a href="https://pub.dartlang.org/documentation/meta/latest/meta/required-constant.html">Required</a>在<a href="https://pub.dartlang.org/packages/meta">meta</a>包中定义。可以直接导入包：<code>package:meta/meta.dart</code>，也可以导入另一个输出<code>meta</code>的包，例如Flutter的包：<code>package:flutter/material.dart</code>。</p>

<h4 id="toc_21">可选位置参数</h4>

<p>在<code>[]</code>中括起来一组函数参数将它们标记为可选的位置参数：</p>

<pre><code class="language-Dart">String say(String from, String msg, [String device]) {
  var result = &#39;$from says $msg&#39;;
  if (device != null) {
    result = &#39;$result with a $device&#39;;
  }
  return result;
}
</code></pre>

<p>这是一个在没有可选参数的情况下调用此函数的示例：</p>

<pre><code class="language-Dart">assert(say(&#39;Bob&#39;, &#39;Howdy&#39;) == &#39;Bob says Howdy&#39;);
</code></pre>

<p>以下是使用第三个参数调用此函数的示例：</p>

<pre><code class="language-Dart">assert(say(&#39;Bob&#39;, &#39;Howdy&#39;, &#39;smoke signal&#39;) ==
    &#39;Bob says Howdy with a smoke signal&#39;);
</code></pre>

<h3 id="toc_22">参数默认值</h3>

<p>您的函数可以使用=来定义命名和位置参数的默认值。默认值必须是编译时常量。如果未提供默认值，则默认值为null。</p>

<p>以下是为命名参数设置默认值的示例：</p>

<pre><code class="language-Dart">/// Sets the [bold] and [hidden] flags ...
void enableFlags({bool bold = false, bool hidden = false}) {...}

// bold will be true; hidden will be false.
enableFlags(bold: true);
</code></pre>

<blockquote>
<p>弃用注释：旧代码可能使用冒号<code>:</code>而不是<code>=</code>来设置命名参数的默认值。原因是最初只有<code>:</code>支持命名参数。该支持可能已弃用，因此我们建议您使用=来指定默认值。</p>
</blockquote>

<p>下一个示例显示如何为位置参数设置默认值：</p>

<pre><code class="language-Dart">String say(String from, String msg,
    [String device = &#39;carrier pigeon&#39;, String mood]) {
  var result = &#39;$from says $msg&#39;;
  if (device != null) {
    result = &#39;$result with a $device&#39;;
  }
  if (mood != null) {
    result = &#39;$result (in a $mood mood)&#39;;
  }
  return result;
}

assert(say(&#39;Bob&#39;, &#39;Howdy&#39;) ==
    &#39;Bob says Howdy with a carrier pigeon&#39;);
</code></pre>

<p>您还可以将Lists或maps作为默认值传递。以下示例定义了一个函数doStuff()，该函数指定list参数的默认list和gifts参数的默认map。</p>

<pre><code class="language-Dart">void doStuff(
    {List&lt;int&gt; list = const [1, 2, 3],
    Map&lt;String, String&gt; gifts = const {
      &#39;first&#39;: &#39;paper&#39;,
      &#39;second&#39;: &#39;cotton&#39;,
      &#39;third&#39;: &#39;leather&#39;
    }}) {
  print(&#39;list:  $list&#39;);
  print(&#39;gifts: $gifts&#39;);
}
</code></pre>

<h2 id="toc_23">main()函数</h2>

<p>每个应用程序都必须具有顶级main()函数，该函数用作应用程序的入口点。 main()函数返回void，并为参数提供可选的List <String>参数。</p>

<p>以下是Web应用程序的main()函数示例：</p>

<pre><code class="language-Dart">void main() {
  querySelector(&#39;#sample_text_id&#39;)
    ..text = &#39;Click me!&#39;
    ..onClick.listen(reverseText);
}
</code></pre>

<blockquote>
<p>注意：前面代码中的<code>..</code>语法称为<a href="https://www.dartlang.org/guides/language/language-tour#cascade-notation-">级联</a>。使用级联，您可以对单个对象的成员执行多个操作。</p>
</blockquote>

<p>以下是带参数的命令行应用程序的main（）函数示例：</p>

<pre><code class="language-Dart">// Run the app like this: dart args.dart 1 test
void main(List&lt;String&gt; arguments) {
  print(arguments);

  assert(arguments.length == 2);
  assert(int.parse(arguments[0]) == 1);
  assert(arguments[1] == &#39;test&#39;);
}
</code></pre>

<p>您可以使用args库来定义和解析命令行参数。</p>

<h3 id="toc_24">函数作为第一类对象</h3>

<p>您可以将函数作为参数传递给另一个函数。例如：</p>

<pre><code class="language-Dart">void printElement(int element) {
  print(element);
}

var list = [1, 2, 3];

// Pass printElement as a parameter.
list.forEach(printElement);
</code></pre>

<p>您还可以为变量分配函数，例如：</p>

<pre><code class="language-Dart">var loudify = (msg) =&gt; &#39;!!! ${msg.toUpperCase()} !!!&#39;;
assert(loudify(&#39;hello&#39;) == &#39;!!! HELLO !!!&#39;);
</code></pre>

<p>此示例使用匿名函数。更多关于下一节的内容。</p>

<h3 id="toc_25">匿名函数</h3>

<p>大多数函数都被命名，例如main()或printElement()。您还可以创建一个名为匿名函数的无名函数，有时也可以创建一个lambda或闭包。您可以为变量分配匿名函数，以便例如可以在集合中添加或删除它。</p>

<p>匿名函数看起来类似于命名函数 - 零个或多个参数，在逗号和括号之间用逗号和可选类型注释分隔。</p>

<p><code>([[Type] param1[, …]]) { <br/>
  codeBlock; <br/>
};</code></p>

<p>以下示例使用无类型参数item定义匿名函数。为列表中的每个项调用的函数将打印一个字符串，该字符串包含指定索引处的值。</p>

<pre><code class="language-Dart">var list = [&#39;apples&#39;, &#39;bananas&#39;, &#39;oranges&#39;];
list.forEach((item) {
  print(&#39;${list.indexOf(item)}: $item&#39;);
});
</code></pre>

<pre><code class="language-Dart">void main() {
  var list = [&#39;apples&#39;, &#39;bananas&#39;, &#39;oranges&#39;];
  list.forEach((item) {
    print(&#39;${list.indexOf(item)}: $item&#39;);
  });
}
</code></pre>

<p>如果函数只包含一个语句，则可以使用箭头表示法缩短它。将以下行粘贴到DartPad中，然后单击“运行”以验证它是否在功能上等效。</p>

<p>以下是在每个范围级别具有变量的嵌套函数的示例：</p>

<pre><code class="language-Dart">bool topLevel = true;

void main() {
  var insideMain = true;

  void myFunction() {
    var insideFunction = true;

    void nestedFunction() {
      var insideNestedFunction = true;

      assert(topLevel);
      assert(insideMain);
      assert(insideFunction);
      assert(insideNestedFunction);
    }
  }
}
</code></pre>

<p>注意<code>nestedFunction()</code>如何使用每个级别的变量，一直到顶级。</p>

<h3 id="toc_26">闭包</h3>

<p>闭包是一个函数对象，它可以访问其词法范围中的变量，即使该函数在其原始范围之外使用也是如此。</p>

<p>函数可以关闭周围范围中定义的变量。在以下示例中，<code>makeAdder()</code>捕获变量<code>addBy</code>。无论返回的函数在哪里，它都会记住addBy。</p>

<pre><code class="language-Dart">/// Returns a function that adds [addBy] to the
/// function&#39;s argument.
Function makeAdder(num addBy) {
  return (num i) =&gt; addBy + i;
}

void main() {
  // Create a function that adds 2.
  var add2 = makeAdder(2);

  // Create a function that adds 4.
  var add4 = makeAdder(4);

  assert(add2(3) == 5);
  assert(add4(3) == 7);
}
</code></pre>

<h3 id="toc_27">测试函数是否相等</h3>

<p>以下是测试顶级函数，静态方法和实例方法的示例：</p>

<pre><code class="language-Dart">void foo() {} // A top-level function

class A {
  static void bar() {} // A static method
  void baz() {} // An instance method
}

void main() {
  var x;

  // Comparing top-level functions.
  x = foo;
  assert(foo == x);

  // Comparing static methods.
  x = A.bar;
  assert(A.bar == x);

  // Comparing instance methods.
  var v = A(); // Instance #1 of A
  var w = A(); // Instance #2 of A
  var y = w;
  x = w.baz;

  // These closures refer to the same instance (#2),
  // so they&#39;re equal.
  assert(y.baz == x);

  // These closures refer to different instances,
  // so they&#39;re unequal.
  assert(v.baz != w.baz);
}
</code></pre>

<h3 id="toc_28">返回值</h3>

<p>所有函数都返回一个值。如果未指定返回值，则该语句返回null;隐式附加到函数体。</p>

<pre><code class="language-Dart">foo() {}

assert(foo() == null);
</code></pre>

<h2 id="toc_29">运算符</h2>

<p>Dart定义下表中显示的运算符。您可以覆盖其中许多运算符，如可<a href="https://www.dartlang.org/guides/language/language-tour#overridable-operators">覆盖运算符</a>中所述。</p>

<table>
<thead>
<tr>
<th>Description</th>
<th>Operator</th>
</tr>
</thead>

<tbody>
<tr>
<td>unary postfix</td>
<td>expr++    expr--    ()    []    .    ?.</td>
</tr>
<tr>
<td>unary prefix</td>
<td>-expr    !expr    ~expr    ++expr    --expr</td>
</tr>
<tr>
<td>multiplicative</td>
<td>*    /    %  ~/</td>
</tr>
<tr>
<td>additive</td>
<td>+    -</td>
</tr>
<tr>
<td>shift</td>
<td>&lt;&lt;    &gt;&gt;</td>
</tr>
<tr>
<td>bitwise AND</td>
<td>&amp;</td>
</tr>
<tr>
<td>bitwise XOR</td>
<td>^</td>
</tr>
<tr>
<td>bitwise OR</td>
<td></td>
</tr>
<tr>
<td>relational and type test</td>
<td>&gt;=    &gt;    &lt;=    &lt;    as    is    is!</td>
</tr>
<tr>
<td>equality</td>
<td>==    !=</td>
</tr>
<tr>
<td>logical AND</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>logical OR</td>
<td></td>
</tr>
<tr>
<td>if null</td>
<td>??</td>
</tr>
<tr>
<td>conditional</td>
<td>expr1 ? expr2 : expr3</td>
</tr>
<tr>
<td>cascade</td>
<td>..</td>
</tr>
<tr>
<td>assignment</td>
<td>=    *=    /=    ~/=    %=    +=    -=    &lt;&lt;=    &gt;&gt;=    &amp;=    <sup>=</sup></td>
</tr>
</tbody>
</table>

<p>使用运算符时，可以创建表达式。以下是运算符表达式的一些示例：</p>

<pre><code class="language-Dart">a++
a + b
a = b
a == b
c ? a : b
a is T
</code></pre>

<p>在运算符表中，每个运算符的优先级高于其后的行中的运算符。例如，乘法运算符％的优先级高于（因此之前执行）等于运算符==，它的优先级高于逻辑AND运算符&amp;&amp;。该优先级意味着以下两行代码执行相同的方式：</p>

<pre><code class="language-Dart">// Parentheses improve readability.
if ((n % i == 0) &amp;&amp; (d % i == 0)) ...

// Harder to read, but equivalent.
if (n % i == 0 &amp;&amp; d % i == 0) ...
</code></pre>

<blockquote>
<p>警告：对于处理两个操作数的运算符，最左边的操作数确定使用哪个版本的运算符。例如，如果您有Vector对象和Point对象，则<code>aVector + aPoint</code>使用Vector版本的+。</p>
</blockquote>

<h3 id="toc_30">算术运算符</h3>

<p>Dart支持通常的算术运算符，如下表所示。</p>

<table>
<thead>
<tr>
<th>Operator</th>
<th>Meaning</th>
</tr>
</thead>

<tbody>
<tr>
<td>+</td>
<td>Add</td>
</tr>
<tr>
<td>–</td>
<td>Subtract</td>
</tr>
<tr>
<td>-expr</td>
<td>Unary minus, also known as negation (reverse the sign of the expression) 一元减号，也称为否定（反转表达式的符号）</td>
</tr>
<tr>
<td>*</td>
<td>Multiply</td>
</tr>
<tr>
<td>/</td>
<td>Divide</td>
</tr>
<tr>
<td>~/</td>
<td>Divide, returning an integer result</td>
</tr>
<tr>
<td>%</td>
<td>Get the remainder of an integer division (modulo)</td>
</tr>
</tbody>
</table>

<p>Example:</p>

<pre><code class="language-Dart">assert(2 + 3 == 5);
assert(2 - 3 == -1);
assert(2 * 3 == 6);
assert(5 / 2 == 2.5); // Result is a double
assert(5 ~/ 2 == 2); // Result is an int
assert(5 % 2 == 1); // Remainder

assert(&#39;5/2 = ${5 ~/ 2} r ${5 % 2}&#39; == &#39;5/2 = 2 r 1&#39;);
</code></pre>

<p>Dart还支持前缀和后缀增量和减量运算符。</p>

<table>
<thead>
<tr>
<th>Operator</th>
<th>Meaning</th>
</tr>
</thead>

<tbody>
<tr>
<td>++var</td>
<td>var = var + 1 (expression value is var + 1)</td>
</tr>
<tr>
<td>var++</td>
<td>var = var + 1 (expression value is var)</td>
</tr>
<tr>
<td>--var</td>
<td>var = var – 1 (expression value is var – 1)</td>
</tr>
<tr>
<td>var--</td>
<td>var = var – 1 (expression value is var)</td>
</tr>
</tbody>
</table>

<p>Example:</p>

<pre><code class="language-Dart">var a, b;

a = 0;
b = ++a; // Increment a before b gets its value.
assert(a == b); // 1 == 1

a = 0;
b = a++; // Increment a AFTER b gets its value.
assert(a != b); // 1 != 0

a = 0;
b = --a; // Decrement a before b gets its value.
assert(a == b); // -1 == -1

a = 0;
b = a--; // Decrement a AFTER b gets its value.
assert(a != b); // -1 != 0
</code></pre>

<h3 id="toc_31">相等和关系运算符</h3>

<p>下表列出了相等和关系运算符的含义。</p>

<table>
<thead>
<tr>
<th>Operator</th>
<th>Meaning</th>
</tr>
</thead>

<tbody>
<tr>
<td>==</td>
<td>Equal; see discussion below</td>
</tr>
<tr>
<td>!=</td>
<td>Not equal</td>
</tr>
<tr>
<td>&gt;</td>
<td>Greater than</td>
</tr>
<tr>
<td>&lt;</td>
<td>Less than</td>
</tr>
<tr>
<td>&gt;=</td>
<td>Greater than or equal to</td>
</tr>
<tr>
<td>&lt;=</td>
<td>Less than or equal to</td>
</tr>
</tbody>
</table>

<p>要测试两个对象x和y是否表示相同的事物，请使用<mark>运算符。 （在极少数情况下，您需要知道两个对象是否是完全相同的对象，请使用<a href="https://api.dartlang.org/stable/dart-core/identical.html">identical()</a>函数。）以下是</mark>运算符的工作原理：</p>

<ol>
<li>如果x或y为null，则如果两者都为null则返回true;如果只有一个为null，则返回false。</li>
<li>返回方法调用<code>x.==(y)</code>的结果。 （没错，运算符如<mark>是在第一个操作数上调用的方法。你甚至可以<a href="https://www.dartlang.org/guides/language/language-tour#overridable-operators">覆盖运算符</a>，包括</mark>，正如你在Overridable运算符中看到的那样。）</li>
</ol>

<p>这是使用每个相等和关系运算符的示例：</p>

<pre><code class="language-Dart">assert(2 == 2);
assert(2 != 3);
assert(3 &gt; 2);
assert(2 &lt; 3);
assert(3 &gt;= 3);
assert(2 &lt;= 3);
</code></pre>

<h3 id="toc_32">类型测试运算符</h3>

<p>as，is，and！运算符在运行时检查类型很方便。</p>

<table>
<thead>
<tr>
<th>Operator</th>
<th>Meaning</th>
</tr>
</thead>

<tbody>
<tr>
<td>as</td>
<td>Typecast</td>
</tr>
<tr>
<td>is</td>
<td>True if the object has the specified type</td>
</tr>
<tr>
<td>is!</td>
<td>False if the object has the specified type</td>
</tr>
</tbody>
</table>

<p>如果obj实现由T指定的接口，则<code>obj is T</code>的结果是true。例如，<code>obj is Object</code>始终为true。</p>

<p>使用as运算符将对象强制转换为特定类型。通常，您应该使用它作为对使用该对象的表达式后跟对象的is测试的简写。例如，请考虑以下代码：</p>

<pre><code class="language-Dart">if (emp is Person) {
  // Type check
  emp.firstName = &#39;Bob&#39;;
}
</code></pre>

<p>您可以使用as运算符缩短代码：</p>

<pre><code class="language-Dart">(emp as Person).firstName = &#39;Bob&#39;;
</code></pre>

<blockquote>
<p>注意：两段代码并不等价。如果emp为null或不是Person，则第一个示例（with is）不执行任何操作;第二个（带有as）抛出一个异常。</p>
</blockquote>

<h3 id="toc_33">赋值运算符</h3>

<p>如您所见，您可以使用=运算符指定值。要仅在assign-to变量为null时分配，请使用<code>??=</code>运算符。</p>

<pre><code class="language-Dart">// 赋值给a
a = value;
// 赋值给b如果b是null; 否则, b 保持不变
b ??= value;
</code></pre>

<p>复合赋值运算符（如+ =）将操作与赋值组合在一起。</p>

<pre><code>=   
–=
/=  
%=
&gt;&gt;= 
^=
+=  
*=  
~/= 
&lt;&lt;= 
&amp;=  
|=
</code></pre>

<p>以下是复合赋值运算符的工作原理：</p>

<table>
<thead>
<tr>
<th></th>
<th>(复合赋值)</th>
<th>(等价表达)</th>
</tr>
</thead>

<tbody>
<tr>
<td>For an operator op:</td>
<td>a op= b</td>
<td>a = a op b</td>
</tr>
<tr>
<td>Example:</td>
<td>a += b</td>
<td>a = a + b</td>
</tr>
</tbody>
</table>

<p>以下示例使用赋值和复合赋值运算符：</p>

<pre><code class="language-Dart">var a = 2; // Assign using =
a *= 3; // Assign and multiply: a = a * 3
assert(a == 6);
</code></pre>

<h3 id="toc_34">逻辑运算符</h3>

<p>您可以使用逻辑运算符反转或组合布尔表达式。</p>

<table>
<thead>
<tr>
<th>Operator</th>
<th>Meaning</th>
</tr>
</thead>

<tbody>
<tr>
<td>!expr</td>
<td>inverts the following expression (changes false to true, and vice versa)</td>
</tr>
<tr>
<td>||</td>
<td>logical OR</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>logical AND</td>
</tr>
</tbody>
</table>

<h3 id="toc_35">按位和移位运算符</h3>

<p>您可以在Dart中操纵数字的各个位。通常，您将使用这些按位和移位运算符和整数。</p>

<table>
<thead>
<tr>
<th>Operator</th>
<th>Meaning</th>
</tr>
</thead>

<tbody>
<tr>
<td>&amp;</td>
<td>AND</td>
</tr>
<tr>
<td></td>
<td>OR</td>
</tr>
<tr>
<td>^</td>
<td>XOR</td>
</tr>
<tr>
<td>~expr</td>
<td>Unary bitwise complement (0s become 1s; 1s become 0s)</td>
</tr>
<tr>
<td>&lt;&lt;  Shift</td>
<td>left</td>
</tr>
<tr>
<td>&gt;&gt;  Shift</td>
<td>right</td>
</tr>
</tbody>
</table>

<p>这是使用按位和移位运算符的示例：</p>

<pre><code class="language-Dart">final value = 0x22;
final bitmask = 0x0f;

assert((value &amp; bitmask) == 0x02); // AND
assert((value &amp; ~bitmask) == 0x20); // AND NOT
assert((value | bitmask) == 0x2f); // OR
assert((value ^ bitmask) == 0x2d); // XOR
assert((value &lt;&lt; 4) == 0x220); // Shift left
assert((value &gt;&gt; 4) == 0x02); // Shift right
</code></pre>

<h3 id="toc_36">条件表达式</h3>

<p>Dart有两个运算符，可以让您简明地计算可能需要<a href="https://www.dartlang.org/guides/language/language-tour#if-and-else">if-else</a>语句的表达式：</p>

<p><code>condition ? expr1 : expr2</code></p>

<p>如果condition为true，则计算expr1（并返回其值）;否则，计算并返回expr2的值。</p>

<p><code>expr1 ?? expr2</code></p>

<p>如果expr1为非null，则返回其值;否则，计算并返回expr2的值。</p>

<p>当您需要根据布尔表达式赋值时，请考虑使用<code>?:</code>。</p>

<pre><code class="language-Dart">var visibility = isPublic ? &#39;public&#39; : &#39;private&#39;;
</code></pre>

<p>如果布尔表达式测试为null，请考虑使用<code>??</code>。</p>

<pre><code class="language-Dart">String playerName(String name) =&gt; name ?? &#39;Guest&#39;;
</code></pre>

<p>前面的例子至少可以用其他两种方式编写，但不是简洁的：</p>

<pre><code class="language-Dart">// Slightly longer version uses ?: operator.
String playerName(String name) =&gt; name != null ? name : &#39;Guest&#39;;

// Very long version uses if-else statement.
String playerName(String name) {
  if (name != null) {
    return name;
  } else {
    return &#39;Guest&#39;;
  }
}
</code></pre>

<h3 id="toc_37">级联符号(..)</h3>

<p>Cascades（..）允许您对同一对象进行一系列操作。除了函数调用，您还可以访问同一对象上的字段。这通常可以为您节省创建临时变量的步骤，并允许您编写更流畅的代码。</p>

<p>请考虑以下代码：</p>

<pre><code class="language-Dart">querySelector(&#39;#confirm&#39;) // 获取对象.
  ..text = &#39;Confirm&#39; // 使用成员变量.
  ..classes.add(&#39;important&#39;)
  ..onClick.listen((e) =&gt; window.alert(&#39;Confirmed!&#39;));
</code></pre>

<p>第一个方法调用<code>querySelector()</code>返回一个选择器对象。级联表示法后面的代码对此选择器对象进行操作，<strong>忽略可能返回的任何后续值</strong>。</p>

<p>前面的示例相当于：</p>

<pre><code class="language-Dart">var button = querySelector(&#39;#confirm&#39;);
button.text = &#39;Confirm&#39;;
button.classes.add(&#39;important&#39;);
button.onClick.listen((e) =&gt; window.alert(&#39;Confirmed!&#39;));
</code></pre>

<p>您也可以嵌套您的级联。例如：</p>

<pre><code class="language-Dart">final addressBook = (AddressBookBuilder()
      ..name = &#39;jenny&#39;
      ..email = &#39;jenny@example.com&#39;
      ..phone = (PhoneNumberBuilder()
            ..number = &#39;415-555-0100&#39;
            ..label = &#39;home&#39;)
          .build())
    .build();
</code></pre>

<p>小心在返回实际对象的函数上构造级联。例如，以下代码失败：</p>

<pre><code class="language-Dart">var sb = StringBuffer();
sb.write(&#39;foo&#39;)
  ..write(&#39;bar&#39;); // Error: method &#39;write&#39; isn&#39;t defined for &#39;void&#39;.
</code></pre>

<p><code>sb.write()</code>调用返回void，您无法在void上构造级联。</p>

<blockquote>
<p>注意：严格来说，级联的“双点”符号不是运算符。它只是Dart语法的一部分。</p>
</blockquote>

<h3 id="toc_38">其他运算符</h3>

<p>在其他示例中，您已经看到了大多数剩余的运算符：</p>

<table>
<thead>
<tr>
<th>Operator</th>
<th>Name</th>
<th>Meaning</th>
</tr>
</thead>

<tbody>
<tr>
<td>()</td>
<td>Function application</td>
<td>Represents a function call</td>
</tr>
<tr>
<td>[]</td>
<td>List access</td>
<td>Refers to the value at the specified index in the list</td>
</tr>
<tr>
<td>.</td>
<td>Member access</td>
<td>Refers to a property of an expression; example: foo.bar selects property bar from expression foo</td>
</tr>
<tr>
<td>?.</td>
<td>Conditional member access</td>
<td>Like ., but the leftmost operand can be null; example: foo?.bar selects property bar from expression foo unless foo is null (in which case the value of foo?.bar is null)</td>
</tr>
</tbody>
</table>

<p>有关<code>.</code>，<code>?.</code>和<code>..</code>运算符的更多信息，请参阅<a href="https://www.dartlang.org/guides/language/language-tour#classes">Classes</a>。</p>

<h2 id="toc_39">控制流程语句</h2>

<p>您可以使用以下任一方法控制Dart代码的流程：</p>

<ul>
<li>if and else</li>
<li>for loops</li>
<li>while and do-while loops</li>
<li>break and continue</li>
<li>switch and case</li>
<li>assert</li>
</ul>

<p>您还可以使用try-catch和throw来影响控制流，如<a href="https://www.dartlang.org/guides/language/language-tour#exceptions">Exceptions</a>中所述。</p>

<h3 id="toc_40">if and else</h3>

<p>Dart支持带有可选else语句的if语句，如下一个示例所示。另见<br/>
<a href="https://www.dartlang.org/guides/language/language-tour#conditional-expressions">conditional expressions</a><br/>
.</p>

<pre><code class="language-Dart">if (isRaining()) {
  you.bringRainCoat();
} else if (isSnowing()) {
  you.wearJacket();
} else {
  car.putTopDown();
}
</code></pre>

<p>与JavaScript不同，条件必须使用布尔值，而不是其他。有关更多信息，请参阅<a href="https://www.dartlang.org/guides/language/language-tour#booleans">Booleans</a>。</p>

<h3 id="toc_41">For loops</h3>

<p>您可以使用标准for循环进行迭代。例如：</p>

<pre><code class="language-Dart">var message = StringBuffer(&#39;Dart is fun&#39;);
for (var i = 0; i &lt; 5; i++) {
  message.write(&#39;!&#39;);
}
</code></pre>

<p>Dart for for循环内部的闭包捕获了索引的值，避免了JavaScript中常见的陷阱。例如，考虑：</p>

<pre><code class="language-Dart">var callbacks = [];
for (var i = 0; i &lt; 2; i++) {
  callbacks.add(() =&gt; print(i));
}
callbacks.forEach((c) =&gt; c());
</code></pre>

<p>正如预期的那样，输出为0然后为1。相比之下，该示例将在JavaScript中打印2然后打印2。</p>

<p>如果要迭代的对象是Iterable，则可以使用forEach（）方法。如果您不需要知道当前的迭代计数器，则使用forEach（）是一个不错的选择：</p>

<pre><code class="language-Dart">candidates.forEach((candidate) =&gt; candidate.interview());
</code></pre>

<p>像List和Set这样的可迭代类也支持迭代的for-in形式：</p>

<pre><code class="language-Dart">var collection = [0, 1, 2];
for (var x in collection) {
  print(x); // 0 1 2
}
</code></pre>

<h3 id="toc_42">While and do-while</h3>

<p>while循环在循环之前计算条件：</p>

<pre><code class="language-Dart">while (!isDone()) {
  doSomething();
}
</code></pre>

<p>do-while循环在循环之后计算条件：</p>

<pre><code class="language-Dart">do {
  printLine();
} while (!atEndOfPage());
</code></pre>

<h3 id="toc_43">Break and continue</h3>

<p>使用break来停止循环：</p>

<pre><code class="language-Dart">while (true) {
  if (shutDownRequested()) break;
  processIncomingRequests();
}
</code></pre>

<p>使用继续跳到下一个循环迭代：</p>

<pre><code class="language-Dart">for (int i = 0; i &lt; candidates.length; i++) {
  var candidate = candidates[i];
  if (candidate.yearsExperience &lt; 5) {
    continue;
  }
  candidate.interview();
}
</code></pre>

<p>如果您使用Iterable（如列表或集合），则可能会以不同的方式编写该示例：</p>

<pre><code class="language-Dart">candidates
    .where((c) =&gt; c.yearsExperience &gt;= 5)
    .forEach((c) =&gt; c.interview());
</code></pre>

<h3 id="toc_44">Switch and case</h3>

<p>Dart中的switch语句使用<code>==</code>比较整数，字符串或编译时常量。比较对象必须都是同一个类的实例（而不是其任何子类型的实例），并且该类不能覆盖==。<a href="https://www.dartlang.org/guides/language/language-tour#enumerated-types">枚举类型</a>在switch语句中运行良好。</p>

<blockquote>
<p>注意：Dart中的Switch语句适用于有限的情况，例如解释器或扫描程序。</p>
</blockquote>

<p>每个非空case子句以break语句结束，作为规则。结束非空case子句的其他有效方法是continue，throw或return语句。</p>

<p>当没有case子句匹配时，使用default子句执行代码：</p>

<pre><code class="language-Dart">var command = &#39;OPEN&#39;;
switch (command) {
  case &#39;CLOSED&#39;:
    executeClosed();
    break;
  case &#39;PENDING&#39;:
    executePending();
    break;
  case &#39;APPROVED&#39;:
    executeApproved();
    break;
  case &#39;DENIED&#39;:
    executeDenied();
    break;
  case &#39;OPEN&#39;:
    executeOpen();
    break;
  default:
    executeUnknown();
}
</code></pre>

<p>以下示例省略了case子句中的break语句，从而生成错误：</p>

<pre><code class="language-Dart">var command = &#39;OPEN&#39;;
switch (command) {
  case &#39;OPEN&#39;:
    executeOpen();
    // ERROR: Missing break

  case &#39;CLOSED&#39;:
    executeClosed();
    break;
}
</code></pre>

<p>但是，Dart确实支持空case 语句，允许一种形式的漏洞：</p>

<pre><code class="language-Dart">var command = &#39;CLOSED&#39;;
switch (command) {
  case &#39;CLOSED&#39;: // Empty case falls through.
  case &#39;NOW_CLOSED&#39;:
    // Runs for both CLOSED and NOW_CLOSED.
    executeNowClosed();
    break;
}

</code></pre>

<p>如果你真的想要fall-through，你可以使用continue语句和标签：</p>

<pre><code class="language-Dart">switch (command) {
  case &#39;CLOSED&#39;:
    executeClosed();
    continue nowClosed;
  // Continues executing at the nowClosed label.

  nowClosed:
  case &#39;NOW_CLOSED&#39;:
    // Runs for both CLOSED and NOW_CLOSED.
    executeNowClosed();
    break;
}
</code></pre>

<p>case子句可以有局部变量，只在该子句的范围内可见。</p>

<h3 id="toc_45">Assert</h3>

<p>如果布尔条件为false，则使用assert语句来中断正常执行。您可以在本导览中找到断言语句的示例。这里还有一些：</p>

<pre><code class="language-Dart">// Make sure the variable has a non-null value.
assert(text != null);

// Make sure the value is less than 100.
assert(number &lt; 100);

// Make sure this is an https URL.
assert(urlString.startsWith(&#39;https&#39;));
</code></pre>

<blockquote>
<p>注意：断言语句对生产代码没有影响;他们只是为了发展。 Flutter在调试模式下启用断言。仅限开发的工具（如dartdevc）通常默认支持断言。某些工具（如dart和dart2js）通过命令行标志支持断言：<code>--enable-asserts</code>。</p>
</blockquote>

<p>要将消息附加到断言，请添加一个字符串作为第二个参数。</p>

<pre><code class="language-Dart">assert(urlString.startsWith(&#39;https&#39;),
    &#39;URL ($urlString) should start with &quot;https&quot;.&#39;);
</code></pre>

<p>assert的第一个参数可以是解析为布尔值的任何表达式。如果表达式的值为true，则断言成功并继续执行。如果为false，则断言失败并抛出异常（AssertionError）。</p>

<h2 id="toc_46">Exceptions</h2>

<p>您的Dart代码可以抛出并捕获异常。例外是指示发生意外事件的错误。如果未捕获异常，则会暂停引发异常的隔离，并且通常会终止隔离及其程序。</p>

<p>与Java相比，Dart的所有异常都是未经检查的异常。方法不会声明它们可能引发的异常，并且您不需要捕获任何异常。</p>

<p>Dart提供了Exception和Error类型，以及许多预定义的子类型。当然，您可以定义自己的例外情况。但是，Dart程序可以抛出任何非null对象 - 不仅仅是Exception和Error对象 - 作为例外。</p>

<h3 id="toc_47">Throw</h3>

<p>以下是抛出或引发异常的示例：</p>

<pre><code class="language-Dart">throw FormatException(&#39;Expected at least 1 section&#39;);
</code></pre>

<p>你也可以抛出任意对象：</p>

<pre><code class="language-Dart">throw &#39;Out of llamas!&#39;;
</code></pre>

<blockquote>
<p>注意：生产质量代码通常会抛出实现错误或异常的类型。</p>
</blockquote>

<p>因为抛出异常是一个表达式，所以可以在=&gt;语句中以及允许表达式的任何其他地方抛出异常：</p>

<pre><code class="language-Dart">void distanceTo(Point other) =&gt; throw UnimplementedError();
</code></pre>

<h3 id="toc_48">Catch</h3>

<p>捕获或捕获异常会阻止异常传播（除非您重新抛出异常）。捕获异常使您有机会处理它：</p>

<pre><code class="language-Dart">try {
  breedMoreLlamas();
} on OutOfLlamasException {
  buyMoreLlamas();
}
</code></pre>

<p>要处理可能抛出多种类型异常的代码，可以指定多个catch子句。与抛出对象的类型匹配的第一个catch子句处理异常。如果catch子句未指定类型，则该子句可以处理任何类型的抛出对象：</p>

<pre><code class="language-Dart">try {
  breedMoreLlamas();
} on OutOfLlamasException {
  // A specific exception
  buyMoreLlamas();
} on Exception catch (e) {
  // Anything else that is an exception
  print(&#39;Unknown exception: $e&#39;);
} catch (e) {
  // No specified type, handles all
  print(&#39;Something really unknown: $e&#39;);
}
</code></pre>

<p>如前面的代码所示，您可以使用on或catch或两者。需要指定异常类型时使用。当异常处理程序需要异常对象时使用catch。</p>

<p>您可以为catch（）指定一个或两个参数。第一个是抛出的异常，第二个是堆栈跟踪（StackTrace对象）。</p>

<pre><code class="language-Dart">try {
  // ···
} on Exception catch (e) {
  print(&#39;Exception details:\n $e&#39;);
} catch (e, s) {
  print(&#39;Exception details:\n $e&#39;);
  print(&#39;Stack trace:\n $s&#39;);
}
</code></pre>

<p>要部分处理异常，同时允许它传播，请使用rethrow关键字。</p>

<pre><code class="language-Dart">void misbehave() {
  try {
    dynamic foo = true;
    print(foo++); // Runtime error
  } catch (e) {
    print(&#39;misbehave() partially handled ${e.runtimeType}.&#39;);
    rethrow; // Allow callers to see the exception.
  }
}

void main() {
  try {
    misbehave();
  } catch (e) {
    print(&#39;main() finished handling ${e.runtimeType}.&#39;);
  }
}
</code></pre>

<h3 id="toc_49">Finally</h3>

<p>要确保某些代码运行，无论是否抛出异常，请使用finally子句。如果没有catch子句与异常匹配，则在finally子句运行后传播异常：</p>

<pre><code class="language-Dart">try {
  breedMoreLlamas();
} finally {
  // Always clean up, even if an exception is thrown.
  cleanLlamaStalls();
}
</code></pre>

<p>finally子句在任何匹配的catch子句之后运行：</p>

<pre><code class="language-Dart">try {
  breedMoreLlamas();
} catch (e) {
  print(&#39;Error: $e&#39;); // Handle the exception first.
} finally {
  cleanLlamaStalls(); // Then clean up.
}
</code></pre>

<p>阅读图书馆之旅的例外部分，了解更多信息。</p>

<h2 id="toc_50">Classes</h2>

<p>Dart是一种面向对象的语言，具有类和基于mixin的继承。每个对象都是一个类的实例，所有类都来自Object。基于Mixin的继承意味着虽然每个类（除了Object）只有一个超类，但是类体可以在多个类层次结构中重用。</p>

<h3 id="toc_51">适用类成员</h3>

<p>对象具有由函数和数据（分别为方法和实例变量）组成的成员。调用方法时，可以在对象上调用它：该方法可以访问该对象的函数和数据。<br/>
使用点（.）来引用实例变量或方法：</p>

<pre><code class="language-Dart">var p = Point(2, 2);

// Set the value of the instance variable y.
p.y = 3;

// Get the value of y.
assert(p.y == 3);

// Invoke distanceTo() on p.
num distance = p.distanceTo(Point(4, 4));
</code></pre>

<p>使用<code>?.</code>代替<code>&#39;</code>当最左边的操作数为null时避免异常：</p>

<pre><code class="language-Dart">// If p is non-null, set its y value to 4.
p?.y = 4;
</code></pre>

<h3 id="toc_52">使用构造函数</h3>

<p>您可以使用构造函数创建对象。构造函数名称可以是<code>ClassName</code>或<code>ClassName.identifier</code>。例如，以下代码使用<code>Point()</code>和<code>Point.fromJson()</code>构造函数创建Point对象：</p>

<pre><code class="language-Dart">var p1 = Point(2, 2);
var p2 = Point.fromJson({&#39;x&#39;: 1, &#39;y&#39;: 2});
</code></pre>

<p>以下代码具有相同的效果，但在构造函数名称之前使用可选的new关键字：</p>

<pre><code class="language-Dart">var p1 = new Point(2, 2);
var p2 = new Point.fromJson({&#39;x&#39;: 1, &#39;y&#39;: 2});
</code></pre>

<blockquote>
<p>版本说明：新关键字在Dart 2中成为可选项。</p>
</blockquote>

<p>有些类提供常量构造函数。要使用常量构造函数创建编译时常量，请将const关键字放在构造函数名称之前：</p>

<pre><code class="language-Dart">var p = const ImmutablePoint(2, 2);
</code></pre>

<p>构造两个相同的编译时常量会产生一个规范的实例：</p>

<pre><code class="language-Dart">var a = const ImmutablePoint(1, 1);
var b = const ImmutablePoint(1, 1);

assert(identical(a, b)); // They are the same instance!
</code></pre>

<p>在常量上下文中，可以在构造函数或文字之前省略const。例如，查看此代码，该代码创建一个const映射：</p>

<pre><code class="language-Dart">const pointAndLine = const {
  &#39;point&#39;: const [const ImmutablePoint(0, 0)],
  &#39;line&#39;: const [const ImmutablePoint(1, 10), const ImmutablePoint(-2, 11)],
};
</code></pre>

<p>您可以省略除const关键字的第一次使用之外的所有内容：</p>

<pre><code class="language-Dart">// Only one const, which establishes the constant context.
const pointAndLine = {
  &#39;point&#39;: [ImmutablePoint(0, 0)],
  &#39;line&#39;: [ImmutablePoint(1, 10), ImmutablePoint(-2, 11)],
};
</code></pre>

<p>如果常量构造函数在常量上下文之外并且在没有const的情况下调用，则会创建一个非常量对象：</p>

<pre><code class="language-Dart">var a = const ImmutablePoint(1, 1); // Creates a constant
var b = ImmutablePoint(1, 1); // Does NOT create a constant

assert(!identical(a, b)); // NOT the same instance!
</code></pre>

<blockquote>
<p>版本说明：在Dart 2的常量上下文中，const关键字变为可选。</p>
</blockquote>

<h3 id="toc_53">获取对象的类型</h3>

<p>要在运行时获取对象的类型，可以使用Object的runtimeType属性，该属性返回Type对象。</p>

<pre><code class="language-Dart">print(&#39;The type of a is ${a.runtimeType}&#39;);
</code></pre>

<p>到目前为止，您已经了解了如何使用类。本节的其余部分将介绍如何实现类。</p>

<h3 id="toc_54">实例变量</h3>

<p>以下是声明实例变量的方法：</p>

<pre><code class="language-Dart">class Point {
  num x; // Declare instance variable x, initially null.
  num y; // Declare y, initially null.
  num z = 0; // Declare z, initially 0.
}
</code></pre>

<p>所有未初始化的实例变量的值都为null。</p>

<p>所有实例变量都生成一个隐式getter方法。非final实例变量也会生成隐式setter方法。有关详细信息，请参阅<a href="https://www.dartlang.org/guides/language/language-tour#getters-and-setters">Getters和setter</a>。</p>

<pre><code class="language-Dart">class Point {
  num x;
  num y;
}

void main() {
  var point = Point();
  point.x = 4; // Use the setter method for x.
  assert(point.x == 4); // Use the getter method for x.
  assert(point.y == null); // Values default to null.
}
</code></pre>

<p>如果在声明实例变量时初始化变量（而不是在构造函数或方法中），则在创建实例时设置该值，该实例在构造函数及其初始化列表执行之前。</p>

<h3 id="toc_55">构造函数</h3>

<p>通过创建一个与其类同名的函数来声明构造函数（另外，还有一个额外的标识符，如命名构造函数中所述）。最常见的构造函数形式，即生成构造函数，创建一个类的新实例：</p>

<pre><code class="language-Dart">class Point {
  num x, y;

  Point(num x, num y) {
    // There&#39;s a better way to do this, stay tuned.
    this.x = x;
    this.y = y;
  }
}
</code></pre>

<p>this关键字引用当前实例。</p>

<blockquote>
<p>注意：仅在存在名称冲突时使用此选项。否则，Dart风格省略了这一点。</p>
</blockquote>

<p>将构造函数参数赋值给实例变量的模式非常常见，Dart具有语法糖，使其变得简单：</p>

<pre><code class="language-Dart">class Point {
  num x, y;

  // Syntactic sugar for setting x and y
  // before the constructor body runs.
  Point(this.x, this.y);
}
</code></pre>

<h4 id="toc_56">默认构造函数</h4>

<p>如果您未声明构造函数，则会为您提供默认构造函数。默认构造函数没有参数，并在超类中调用无参数构造函数。</p>

<h4 id="toc_57">构造函数会被继承</h4>

<p>子类不从其超类继承构造函数。声明没有构造函数的子类只有默认（无参数，无名称）构造函数。</p>

<h4 id="toc_58">命名构造函数</h4>

<p>使用命名构造函数为类实现多个构造函数或提供额外的清晰度：</p>

<pre><code class="language-Dart">class Point {
  num x, y;

  Point(this.x, this.y);

  // Named constructor
  Point.origin() {
    x = 0;
    y = 0;
  }
}
</code></pre>

<p>请记住，构造函数不是继承的，这意味着超类的命名构造函数不会被子类继承。如果希望使用超类中定义的命名构造函数创建子类，则必须在子类中实现该构造函数。</p>

<h4 id="toc_59">调用非默认的超类构造函数</h4>

<p>默认情况下，子类中的构造函数调用超类的未命名的无参数构造函数。超类的构造函数在构造函数体的开头被调用。如果还使用<a href="https://www.dartlang.org/guides/language/language-tour#initializer-list">初始化列表</a>，则在调用超类之前执行。总之，执行顺序如下：</p>

<ol>
<li>初始化列表 </li>
<li>超类的无参数构造函数 </li>
<li>主类的无参数构造函数</li>
</ol>

<p>如果超类没有未命名的无参数构造函数，则必须手动调用超类中的一个构造函数。在冒号（:)之后指定超类构造函数，就在构造函数体（如果有）之前。</p>

<p>在下面的示例中，Employee类的构造函数为其超类Person调用命名构造函数。单击“运行”按钮以执行代码。</p>

<pre><code class="language-Dart">class Person {
  String firstName;

  Person.fromJson(Map data) {
    print(&#39;in Person&#39;);
  }
}

class Employee extends Person {
  // Person does not have a default constructor;
  // you must call super.fromJson(data).
  Employee.fromJson(Map data) : super.fromJson(data) {
    print(&#39;in Employee&#39;);
  }
}

main() {
  var emp = new Employee.fromJson({});

  // Prints:
  // in Person
  // in Employee
  if (emp is Person) {
    // Type check
    emp.firstName = &#39;Bob&#39;;
  }
  (emp as Person).firstName = &#39;Bob&#39;;
}
</code></pre>

<p>因为在调用构造函数之前会计算超类构造函数的参数，所以参数可以是一个表达式，例如函数调用：</p>

<pre><code class="language-Dart">class Employee extends Person {
  Employee() : super.fromJson(getDefaultData());
  // ···
}
</code></pre>

<blockquote>
<p>警告：超类构造函数的参数无权用<code>this</code>访问它。例如，参数可以调用静态方法，但不能调用实例方法。</p>
</blockquote>

<h5 id="toc_60">初始化列表</h5>

<p>除了调用超类构造函数之外，还可以在构造函数体运行之前初始化实例变量。用逗号分隔初始化程序。</p>

<pre><code class="language-Dart">// Initializer list sets instance variables before
// the constructor body runs.
Point.fromJson(Map&lt;String, num&gt; json)
    : x = json[&#39;x&#39;],
      y = json[&#39;y&#39;] {
  print(&#39;In Point.fromJson(): ($x, $y)&#39;);
}
</code></pre>

<blockquote>
<p>警告：初始化程序中无法适用<code>this</code>关键字</p>
</blockquote>

<p>在开发期间，您可以使用初始化列表中的assert来验证输入。</p>

<pre><code class="language-Dart">Point.withAssert(this.x, this.y) : assert(x &gt;= 0) {
  print(&#39;In Point.withAssert(): ($x, $y)&#39;);
}
</code></pre>

<p>设置最终字段时，初始化程序列表很方便。以下示例初始化初始化列表中的三个最终字段。单击“运行”按钮以执行代码。</p>

<pre><code class="language-Dart">import &#39;dart:math&#39;;

class Point {
  final num x;
  final num y;
  final num distanceFromOrigin;

  Point(x, y)
      : x = x,
        y = y,
        distanceFromOrigin = sqrt(x * x + y * y);
}

main() {
  var p = new Point(2, 3);
  print(p.distanceFromOrigin);
}
</code></pre>

<h4 id="toc_61">重定向构造函数</h4>

<p>有时构造函数的唯一目的是重定向到同一个类中的另一个构造函数。重定向构造函数的主体是空的，构造函数调用出现在冒号（:)之后。</p>

<pre><code class="language-Dart">class Point {
  num x, y;

  // The main constructor for this class.
  Point(this.x, this.y);

  // Delegates to the main constructor.
  Point.alongXAxis(num x) : this(x, 0);
}
</code></pre>

<h4 id="toc_62">常量构造函数</h4>

<p>如果您的类生成永远不会更改的对象，则可以使这些对象成为编译时常量。为此，请定义const构造函数并确保所有实例变量都是final。</p>

<pre><code class="language-Dart">class ImmutablePoint {
  static final ImmutablePoint origin =
      const ImmutablePoint(0, 0);

  final num x, y;

  const ImmutablePoint(this.x, this.y);
}
</code></pre>

<p>常量构造函数并不总是创建常量。有关详细信息，请参阅有关<a href="https://www.dartlang.org/guides/language/language-tour#using-constructors">使用构造函数</a>的部分。</p>

<h4 id="toc_63">工厂构造函数</h4>

<p>在实现并不总是创建其类的新实例的构造函数时，请使用factory关键字。例如，工厂构造函数可能从缓存中返回实例，或者它可能返回子类型的实例。</p>

<p>以下示例演示了从缓存中返回对象的工厂构造函数：</p>

<pre><code class="language-Dart">class Logger {
  final String name;
  bool mute = false;

  // _cache is library-private, thanks to
  // the _ in front of its name.
  static final Map&lt;String, Logger&gt; _cache =
      &lt;String, Logger&gt;{};

  factory Logger(String name) {
    if (_cache.containsKey(name)) {
      return _cache[name];
    } else {
      final logger = Logger._internal(name);
      _cache[name] = logger;
      return logger;
    }
  }

  Logger._internal(this.name);

  void log(String msg) {
    if (!mute) print(msg);
  }
}
</code></pre>

<blockquote>
<p>注意：工厂构造函数无权使用<code>this</code>。</p>
</blockquote>

<p>像调用任何其他构造函数一样调用工厂构造函数：</p>

<pre><code class="language-Dart">var logger = Logger(&#39;UI&#39;);
logger.log(&#39;Button clicked&#39;);
</code></pre>

<h2 id="toc_64">Methods</h2>

<p>方法是为对象提供行为的函数。</p>

<h3 id="toc_65">实例方法</h3>

<p>对象上的实例方法可以访问实例变量和它。以下示例中的distanceTo（）方法是实例方法的示例：</p>

<pre><code class="language-Dart">import &#39;dart:math&#39;;

class Point {
  num x, y;

  Point(this.x, this.y);

  num distanceTo(Point other) {
    var dx = x - other.x;
    var dy = y - other.y;
    return sqrt(dx * dx + dy * dy);
  }
}
</code></pre>

<h3 id="toc_66">Getters and setters</h3>

<p>getter和setter是提供对象属性的读写访问权限的特殊方法。回想一下，每个实例变量都有一个隐式getter，如果合适的话还有一个setter。您可以使用get和set关键字通过实现getter和setter来创建其他属性：</p>

<pre><code class="language-Dart">class Rectangle {
  num left, top, width, height;

  Rectangle(this.left, this.top, this.width, this.height);

  // Define two calculated properties: right and bottom.
  num get right =&gt; left + width;
  set right(num value) =&gt; left = value - width;
  num get bottom =&gt; top + height;
  set bottom(num value) =&gt; top = value - height;
}

void main() {
  var rect = Rectangle(3, 4, 20, 15);
  assert(rect.left == 3);
  rect.right = 12;
  assert(rect.left == -8);
}
</code></pre>

<p>使用getter和setter，您可以从实例变量开始，稍后使用方法包装它们，而无需更改客户端代码。</p>

<blockquote>
<p>注意：无论是否明确定义了getter，增量（++）等运算符都以预期的方式工作。为避免任何意外的副作用，操作员只需调用一次getter，将其值保存在临时变量中。</p>
</blockquote>

<h3 id="toc_67">抽象方法</h3>

<p>实例，getter和setter方法可以是抽象的，定义一个接口，但将其实现留给其他类。抽象方法只能存在于<a href="https://www.dartlang.org/guides/language/language-tour#abstract-classes">抽象类</a>中。</p>

<p>要使方法抽象，请使用分号（;）而不是方法体：</p>

<pre><code class="language-Dart">abstract class Doer {
  // Define instance variables and methods...

  void doSomething(); // Define an abstract method.
}

class EffectiveDoer extends Doer {
  void doSomething() {
    // Provide an implementation, so the method is not abstract here...
  }
}
</code></pre>

<h2 id="toc_68">抽象类</h2>

<p>使用abstract修饰符定义抽象类 - 无法实例化的类。抽象类对于定义接口非常有用，通常还有一些实现。如果希望抽象类看起来是可实例化的，请定义工厂构造函数。</p>

<p>抽象类通常有抽象方法。这是一个声明具有抽象方法的抽象类的示例：</p>

<pre><code class="language-Dart">// This class is declared abstract and thus
// can&#39;t be instantiated.
abstract class AbstractContainer {
  // Define constructors, fields, methods...

  void updateChildren(); // Abstract method.
}
</code></pre>

<h2 id="toc_69">隐式接口</h2>

<p>每个类都隐式定义一个接口，该接口包含该类的所有实例成员及其实现的任何接口。如果要在不继承B实现的情况下创建支持B类API的A类，则A类应实现B接口。</p>

<p>类通过在implements子句中声明它们然后提供接口所需的API来实现一个或多个接口。例如：</p>

<pre><code class="language-Dart">// A person. The implicit interface contains greet().
class Person {
  // In the interface, but visible only in this library.
  final _name;

  // Not in the interface, since this is a constructor.
  Person(this._name);

  // In the interface.
  String greet(String who) =&gt; &#39;Hello, $who. I am $_name.&#39;;
}

// An implementation of the Person interface.
class Impostor implements Person {
  get _name =&gt; &#39;&#39;;

  String greet(String who) =&gt; &#39;Hi $who. Do you know who I am?&#39;;
}

String greetBob(Person person) =&gt; person.greet(&#39;Bob&#39;);

void main() {
  print(greetBob(Person(&#39;Kathy&#39;)));
  print(greetBob(Impostor()));
}
</code></pre>

<p>这是一个指定类实现多个接口的示例：</p>

<pre><code class="language-Dart">class Point implements Comparable, Location {...}
</code></pre>

<h2 id="toc_70">Extending a class</h2>

<p>使用extends创建子类，使用super来引用超类：</p>

<pre><code class="language-Dart">class Television {
  void turnOn() {
    _illuminateDisplay();
    _activateIrSensor();
  }
  // ···
}

class SmartTelevision extends Television {
  void turnOn() {
    super.turnOn();
    _bootNetworkInterface();
    _initializeMemory();
    _upgradeApps();
  }
  // ···
}
</code></pre>

<h3 id="toc_71">重写(覆盖)成员</h3>

<p>子类可以覆盖实例方法，getter和setter。您可以使用@override注释来指示您有意覆盖成员：</p>

<pre><code class="language-Dart">class SmartTelevision extends Television {
  @override
  void turnOn() {...}
  // ···
}
</code></pre>

<p>要在类型安全的代码中缩小方法参数或实例变量的类型，可以使用<a href="https://www.dartlang.org/guides/language/sound-problems#the-covariant-keyword">covariant关键字</a>。</p>

<h3 id="toc_72">可覆盖操作符</h3>

<p>您可以覆盖下表中显示的运算符。例如，如果定义Vector类，则可以定义一个+方法来添加两个向量。</p>

<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>&lt;</td>
<td>+</td>
<td>|</td>
<td>[]</td>
</tr>
<tr>
<td>&gt;</td>
<td>/</td>
<td>^</td>
<td>[]=</td>
</tr>
<tr>
<td>&lt;=</td>
<td>~/</td>
<td>&amp;</td>
<td>~</td>
</tr>
<tr>
<td>&gt;=</td>
<td>*</td>
<td>&lt;&lt;</td>
<td>==</td>
</tr>
<tr>
<td>–</td>
<td>%</td>
<td>&gt;&gt;</td>
<td></td>
</tr>
</tbody>
</table>

<blockquote>
<p>注意：您可能已经注意到！=不是可覆盖的运算符。表达式e1！= e2只是！（e1 == e2）的语法糖。</p>
</blockquote>

<p>这是一个覆盖+和 - 运算符的类的示例：</p>

<pre><code class="language-Dart">class Vector {
  final int x, y;

  Vector(this.x, this.y);

  Vector operator +(Vector v) =&gt; Vector(x + v.x, y + v.y);
  Vector operator -(Vector v) =&gt; Vector(x - v.x, y - v.y);

  // Operator == and hashCode not shown. For details, see note below.
  // ···
}

void main() {
  final v = Vector(2, 3);
  final w = Vector(2, 2);

  assert(v + w == Vector(4, 5));
  assert(v - w == Vector(0, 1));
}
</code></pre>

<p>如果覆盖<mark>，则还应该覆盖Object的hashCode getter。有关重写</mark>和hashCode的示例，请参阅<a href="https://www.dartlang.org/guides/libraries/library-tour#implementing-map-keys">Implementing map keys</a>。</p>

<p>有关覆盖的更多信息，请参阅<a href="https://www.dartlang.org/guides/language/language-tour#extending-a-class">扩展类</a>。</p>

<h3 id="toc_73">noSuchMethod()</h3>

<p>要在代码尝试使用不存在的方法或实例变量时检测或做出反应，您可以覆盖<code>noSuchMethod()</code>：</p>

<pre><code class="language-Dart">class A {
  // Unless you override noSuchMethod, using a
  // non-existent member results in a NoSuchMethodError.
  @override
  void noSuchMethod(Invocation invocation) {
    print(&#39;You tried to use a non-existent member: &#39; +
        &#39;${invocation.memberName}&#39;);
  }
}
</code></pre>

<p>除非满足下列条件之一，否则不能调用未实现的方法：</p>

<ul>
<li><p>The receiver has the static type dynamic.</p></li>
<li><p>The receiver has a static type that defines the unimplemented method (abstract is OK), and the dynamic type of the receiver has an implemention of noSuchMethod() that’s different from the one in class Object.</p></li>
</ul>

<p>有关更多信息，请参阅非正式<a href="https://github.com/dart-lang/sdk/blob/master/docs/language/informal/nosuchmethod-forwarding.md">noSuchMethod转发规范</a>。</p>

<h2 id="toc_74">枚举类型</h2>

<p>枚举类型（通常称为枚举或枚举）是一种特殊类，用于表示固定数量的常量值。</p>

<h3 id="toc_75">使用枚举</h3>

<p>使用enum关键字声明枚举类型：</p>

<pre><code class="language-Dart">enum Color { red, green, blue }
</code></pre>

<p>枚举中的每个值都有一个索引getter，它返回枚举声明中值的从零开始的位置。例如，第一个值具有索引0，第二个值具有索引1。</p>

<pre><code class="language-Dart">assert(Color.red.index == 0);
assert(Color.green.index == 1);
assert(Color.blue.index == 2);
</code></pre>

<p>要获取枚举中所有值的列表，请使用枚举值常量。</p>

<pre><code class="language-Dart">List&lt;Color&gt; colors = Color.values;
assert(colors[2] == Color.blue);
</code></pre>

<p>您可以在switch语句中使用枚举，如果您不处理所有枚举值，您将收到警告：</p>

<pre><code class="language-Dart">var aColor = Color.blue;

switch (aColor) {
  case Color.red:
    print(&#39;Red as roses!&#39;);
    break;
  case Color.green:
    print(&#39;Green as grass!&#39;);
    break;
  default: // Without this, you see a WARNING.
    print(aColor); // &#39;Color.blue&#39;
}
</code></pre>

<p>枚举类型具有以下限制：</p>

<ul>
<li>您不能子类化，混合或实现枚举。</li>
<li>您无法显式实例化枚举。</li>
</ul>

<p>有关更多信息，请参阅<a href="https://www.dartlang.org/guides/language/spec">Dart语言规范</a>。</p>

<h3 id="toc_76">向类添加功能：mixins</h3>

<p>Mixins是一种在多个类层次结构中重用类代码的方法。</p>

<p>要使用mixin，请使用with关键字，后跟一个或多个mixin名称。以下示例显示了两个使用mixins的类：</p>

<pre><code class="language-Dart">class Musician extends Performer with Musical {
  // ···
}

class Maestro extends Person
    with Musical, Aggressive, Demented {
  Maestro(String maestroName) {
    name = maestroName;
    canConduct = true;
  }
}
</code></pre>

<p>要实现一个mixin，创建一个扩展Object的类，声明没有构造函数，并且没有调用super。例如：</p>

<pre><code class="language-Dart">abstract class Musical {
  bool canPlayPiano = false;
  bool canCompose = false;
  bool canConduct = false;

  void entertainMe() {
    if (canPlayPiano) {
      print(&#39;Playing piano&#39;);
    } else if (canConduct) {
      print(&#39;Waving hands&#39;);
    } else {
      print(&#39;Humming to self&#39;);
    }
  }
}
</code></pre>

<blockquote>
<p>注意：正在删除对mixin的一些限制。有关详细信息，请参阅<a href="https://github.com/dart-lang/sdk/blob/master/docs/language/informal/mixin-declaration.md">建议的mixin规范</a>。</p>
</blockquote>

<p>有关Dart中mixins演变的理论介绍，请参阅<a href="https://www.dartlang.org/articles/language/mixins">Dart中Mixins的简史</a>。</p>

<h3 id="toc_77">Class variables and methods</h3>

<p>使用static关键字实现类范围的变量和方法。</p>

<h4 id="toc_78">静态变量</h4>

<p>静态变量（类变量）对于类范围的状态和常量很有用：</p>

<pre><code class="language-Dart">class Queue {
  static const initialCapacity = 16;
  // ···
}

void main() {
  assert(Queue.initialCapacity == 16);
}
</code></pre>

<p>静态变量在使用之前不会初始化。</p>

<blockquote>
<p>注意：此页面遵循样式指南建议，优先选择lowerCamelCase作为常量名称。</p>
</blockquote>

<h4 id="toc_79">静态方法</h4>

<p>静态方法（类方法）不对实例进行操作，因此<code>this</code>无法访问它。例如：</p>

<pre><code class="language-Dart">import &#39;dart:math&#39;;

class Point {
  num x, y;
  Point(this.x, this.y);

  static num distanceBetween(Point a, Point b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
  }
}

void main() {
  var a = Point(2, 2);
  var b = Point(4, 4);
  var distance = Point.distanceBetween(a, b);
  assert(2.8 &lt; distance &amp;&amp; distance &lt; 2.9);
  print(distance);
}
</code></pre>

<blockquote>
<p>注意：对于常用或广泛使用的实用程序和功能，请考虑使用顶级函数而不是静态方法。</p>
</blockquote>

<h2 id="toc_80">泛型</h2>

<p>如果查看基本数组类型的API文档List，您会看到该类型实际上是List <E>。 &lt;...&gt;表示法将List标记为通用（或参数化）类型 - 具有正式类型参数的类型。按照惯例，类型变量具有单字母名称，例如E，T，S，K和V.</p>

<h3 id="toc_81">为什么要使用泛型？</h3>

<p>类型安全通常需要泛型，但它们比仅允许代码运行有更多好处：</p>

<ul>
<li>正确指定泛型类型可以生成更好的代码。 </li>
<li>您可以使用泛型来减少代码重复。</li>
</ul>

<p>如果您希望列表只包含字符串，则可以将其声明为List <String>（将其称为“字符串列表”）。这样，您，您的程序员和您的工具可以检测到将非字符串分配给列表可能是一个错误。这是一个例子：</p>

<pre><code class="language-Dart">var names = List&lt;String&gt;();
names.addAll([&#39;Seth&#39;, &#39;Kathy&#39;, &#39;Lars&#39;]);
names.add(42); // Error
</code></pre>

<p>使用泛型的另一个原因是减少代码重复。泛型允许您在多种类型之间共享单个接口和实现，同时仍然利用静态分析。例如，假设您创建了一个用于缓存对象的接口：</p>

<pre><code class="language-Dart">abstract class ObjectCache {
  Object getByKey(String key);
  void setByKey(String key, Object value);
}
</code></pre>

<p>您发现需要此接口的特定于字符串的版本，因此您需要创建另一个接口：</p>

<pre><code class="language-Dart">abstract class StringCache {
  String getByKey(String key);
  void setByKey(String key, String value);
}
</code></pre>

<p>之后，您决定要使用此接口的特定数字版本......您会明白这一点。</p>

<p>通用类型可以省去创建所有这些接口的麻烦。相反，您可以创建一个带有类型参数的接口：</p>

<pre><code class="language-Dart">abstract class Cache&lt;T&gt; {
  T getByKey(String key);
  void setByKey(String key, T value);
}
</code></pre>

<p>在此代码中，T是替身类型。它是一个占位符，您可以将其视为开发人员稍后定义的类型。</p>

<h3 id="toc_82">Using collection literals</h3>

<p>list和map可以参数化。参数化文字就像你已经看到的文字一样，除了你在开始括号之前添加<type>（对于列表）或<keyType，valueType>（对于maps）。以下是使用类型文字的示例：</p>

<pre><code class="language-Dart">var names = &lt;String&gt;[&#39;Seth&#39;, &#39;Kathy&#39;, &#39;Lars&#39;];
var pages = &lt;String, String&gt;{
  &#39;index.html&#39;: &#39;Homepage&#39;,
  &#39;robots.txt&#39;: &#39;Hints for web robots&#39;,
  &#39;humans.txt&#39;: &#39;We are people, not machines&#39;
};
</code></pre>

<h3 id="toc_83">使用带有构造函数的参数化类型</h3>

<p>要在使用构造函数时指定一个或多个类型，请将类型放在尖括号（&lt;...&gt;）的类名后面。例如：</p>

<pre><code class="language-Dart">var names = List&lt;String&gt;();
names.addAll([&#39;Seth&#39;, &#39;Kathy&#39;, &#39;Lars&#39;]);
var nameSet = Set&lt;String&gt;.from(names);
</code></pre>

<p>以下代码创建一个具有整数键和View类型值的映射：</p>

<pre><code class="language-Dart">var views = Map&lt;int, View&gt;();
</code></pre>

<h3 id="toc_84">泛型集合及其包含的类型</h3>

<p>Dart泛型类型被定义，这意味着它们在运行时携带它们的类型信息。例如，您可以测试集合的类型：</p>

<pre><code class="language-Dart">var names = List&lt;String&gt;();
names.addAll([&#39;Seth&#39;, &#39;Kathy&#39;, &#39;Lars&#39;]);
print(names is List&lt;String&gt;); // true
</code></pre>

<blockquote>
<p>注意：相反，Java中的泛型使用擦除，这意味着在运行时删除泛型类型参数。在Java中，您可以测试对象是否为List，但无法测试它是否为List <String>。</p>
</blockquote>

<h3 id="toc_85">限制参数化类型</h3>

<p>实现泛型类型时，您可能希望限制其参数的类型。您可以使用<code>extends</code>来执行此操作。</p>

<pre><code class="language-Dart">class Foo&lt;T extends SomeBaseClass&gt; {
  // Implementation goes here...
  String toString() =&gt; &quot;Instance of &#39;Foo&lt;$T&gt;&#39;&quot;;
}

class Extender extends SomeBaseClass {...}
</code></pre>

<p>可以使用SomeBaseClass或其任何子类作为通用参数：</p>

<pre><code class="language-Dart">var someBaseClassFoo = Foo&lt;SomeBaseClass&gt;();
var extenderFoo = Foo&lt;Extender&gt;();
</code></pre>

<p>也可以不指定泛型参数：</p>

<pre><code class="language-Dart">var foo = Foo();
print(foo); // Instance of &#39;Foo&lt;SomeBaseClass&gt;&#39;
</code></pre>

<p>指定任何非SomeBaseClass类型会导致错误：</p>

<pre><code class="language-Dart">var foo = Foo&lt;Object&gt;();
</code></pre>

<h3 id="toc_86">使用泛型方法</h3>

<p>最初，Dart的泛型支持仅限于类。一种称为泛型方法的新语法允许在方法和函数上使用类型参数：</p>

<pre><code class="language-Dart">T first&lt;T&gt;(List&lt;T&gt; ts) {
  // Do some initial work or error checking, then...
  T tmp = ts[0];
  // Do some additional checking or processing...
  return tmp;
}
</code></pre>

<p>这里，first（<T>）上的泛型类型参数允许您在几个地方使用类型参数T：</p>

<ul>
<li>在函数的返回类型（T）中。 </li>
<li>在参数的类型（List <T>）中。 </li>
<li>在局部变量的类型（T tmp）。</li>
</ul>

<p>有关泛型的更多信息，请参阅<a href="https://github.com/dart-lang/sdk/blob/master/pkg/dev_compiler/doc/GENERIC_METHODS.md">使用泛型方法</a>。</p>

<h2 id="toc_87">Libraries and visibility</h2>

<p><code>impotr</code>和<code>library</code>指令可以帮助您创建模块化和可共享的代码库。 库不仅提供API，还是隐私单元：以下划线（_）开头的标识符仅在库内可见。 每个Dart应用程序都是一个库，即使它不使用库指令。</p>

<p>可以使用包来分发库。有关pub（包含在SDK中的包管理器）的信息，请参阅<a href="https://www.dartlang.org/tools/pub">Pub Package和Asset Manager</a>。</p>

<h3 id="toc_88">使用库</h3>

<p>使用import指定如何在另一个库的范围内使用来自一个库的命名空间。</p>

<p>例如，Dart Web应用程序通常使用dart：html库，它们可以像这样导入：</p>

<pre><code class="language-Dart">import &#39;dart:html&#39;;
</code></pre>

<p>导入的唯一必需参数是指定库的URI。对于内置库，URI具有特殊的dart：scheme。对于其他库，您可以使用文件系统路径或package：scheme。 package：scheme指定由包管理器（如pub工具）提供的库。例如：</p>

<pre><code class="language-Dart">import &#39;package:test/test.dart&#39;;
</code></pre>

<p>注意：URI代表统一资源标识符。 URL（统一资源定位符）是一种常见的URI。</p>

<h3 id="toc_89">指定库前缀</h3>

<p>如果导入两个具有冲突标识符的库，则可以为一个或两个库指定前缀。例如，如果library1和library2都有一个Element类，那么你可能有这样的代码：</p>

<pre><code class="language-Dart">import &#39;package:lib1/lib1.dart&#39;;
import &#39;package:lib2/lib2.dart&#39; as lib2;

// Uses Element from lib1.
Element element1 = Element();

// Uses Element from lib2.
lib2.Element element2 = lib2.Element();
</code></pre>

<h3 id="toc_90">仅导入库的一部分</h3>

<p>如果只想使用库的一部分，则可以有选择地导入库。例如：</p>

<pre><code class="language-Dart">// Import only foo.
import &#39;package:lib1/lib1.dart&#39; show foo;

// Import all names EXCEPT foo.
import &#39;package:lib2/lib2.dart&#39; hide foo;
</code></pre>

<h3 id="toc_91">懒加载一个库</h3>

<p>延迟加载（也称为延迟加载）允许应用程序根据需要加载库，如果需要的话。以下是您可能使用延迟加载的一些情况：</p>

<ul>
<li>减少应用程序的初始启动时间。 </li>
<li>例如，执行A / B测试 - 尝试算法的替代实现。 </li>
<li>加载很少使用的功能，例如可选的屏幕和对话框。</li>
</ul>

<p>要延迟加载库，必须先使用deferred导入它。</p>

<pre><code class="language-Dart">import &#39;package:greetings/hello.dart&#39; deferred as hello;
</code></pre>

<p>当您需要库时，使用库的标识符调用<code>loadLibrary()</code>。</p>

<pre><code>Future greet() async {
  await hello.loadLibrary();
  hello.printGreeting();
}
</code></pre>

<p>在前面的代码中，await关键字暂停执行，直到加载库。有关async和await的详细信息，请参阅<a href="https://www.dartlang.org/guides/language/language-tour#asynchrony-support">异步支持</a>。</p>

<p>您可以在库上多次调用<code>loadLibrary()</code>而不会出现问题。该库只加载一次。</p>

<p>使用延迟加载时请记住以下内容：</p>

<ul>
<li>延迟库的常量不是导入文件中的常量。请记住，在加载延迟库之前，这些常量不存在。</li>
<li>您不能在导入文件中使用延迟库中的类型。相反，请考虑将接口类型移动到由延迟库和导入文件导入的库。</li>
<li>Dart隐式地将loadLibrary()插入到使用deferred as namespace定义的命名空间中。 loadLibrary()函数返回Future。</li>
</ul>

<blockquote>
<p>Dart VM差异：即使在调用loadLibrary（）之前，Dart VM也允许访问延迟库的成员。此行为可能会更改，因此不要依赖于当前的VM行为。有关详细信息，请参阅<a href="https://github.com/dart-lang/sdk/issues/33118">问题＃33118</a>。</p>
</blockquote>

<h3 id="toc_92">实现库</h3>

<p>有关如何实现库包的建议，请参阅<a href="https://www.dartlang.org/guides/libraries/create-library-packages">创建库包</a>，包括：</p>

<ul>
<li>如何组织库源代码。 </li>
<li>如何使用export指令。 </li>
<li>何时使用part指令。</li>
</ul>

<h2 id="toc_93">异步支持</h2>

<p>Dart库中包含许多返回Future或Stream对象的函数。这些函数是异步的：它们在设置可能耗时的操作（例如I / O）后返回，而不等待该操作完成。</p>

<p>async和await关键字支持异步编程，允许您编写看起来类似于同步代码的异步代码。</p>

<h3 id="toc_94">Handling Futures(处理期货)</h3>

<p>当您需要完成的Future的结果时，您有两个选择：</p>

<ul>
<li>使用async和await。</li>
<li>使用Future API，如<a href="https://www.dartlang.org/guides/libraries/library-tour#future">the library tour</a>中所述。</li>
</ul>

<p>使用async和await的代码是异步的，但它看起来很像同步代码。例如，这里有一些代码使用await来等待异步函数的结果：</p>

<pre><code class="language-Dart">await lookUpVersion();
</code></pre>

<p>要使用await，代码必须位于异步函数中 - 标记为async的函数：</p>

<pre><code class="language-Dart">Future checkVersion() async {
  var version = await lookUpVersion();
  // Do something with version
}
</code></pre>

<blockquote>
<p>注意：虽然异步函数可能执行耗时的操作，但它不会等待这些操作。相反，异步函数只在遇到第一个await表达式（<a href="https://github.com/dart-lang/sdk/blob/master/docs/newsletter/20170915.md#synchronous-async-start">详细信息</a>）时才会执行。然后它返回一个Future对象，仅在await表达式完成后才恢复执行。</p>
</blockquote>

<p>使用try，catch，最后在使用await的代码中处理错误和清理：</p>

<pre><code class="language-Dart">try {
  version = await lookUpVersion();
} catch (e) {
  // React to inability to look up the version
}
</code></pre>

<p>您可以在异步函数中多次使用等待。例如，以下代码等待三次函数结果：</p>

<pre><code class="language-Dart">var entrypoint = await findEntrypoint();
var exitCode = await runExecutable(entrypoint, args);
await flushThenExit(exitCode);
</code></pre>

<p>在await表达式中，表达式的值通常是Future;如果不是，那么该值将自动包含在Future中。此Future对象表示返回对象的承诺。 await表达式的值是返回的对象。 await表达式使执行暂停，直到该对象可用。</p>

<p>如果在使用await时遇到编译时错误，请确保await在异步函数中。例如，要在应用程序的main（）函数中使用await，main（）的主体必须标记为async：</p>

<pre><code class="language-Dart">Future main() async {
  checkVersion();
  print(&#39;In main: version is ${await lookUpVersion()}&#39;);
}
</code></pre>

<h3 id="toc_95">声明异步函数</h3>

<p>异步函数是一个函数，其主体用async修饰符标记。</p>

<p>将async关键字添加到函数使其返回Future。例如，考虑这个同步函数，它返回一个String：</p>

<pre><code class="language-Dart">String lookUpVersion() =&gt; &#39;1.0.0&#39;;
</code></pre>

<p>如果将其更改为异步函数 - 例如，因为将来的实现将非常耗时 - 返回的值是Future：</p>

<pre><code class="language-Dart">Future&lt;String&gt; lookUpVersion() async =&gt; &#39;1.0.0&#39;;
</code></pre>

<p>请注意，函数的主体不需要使用Future API。如有必要，Dart会创建Future对象。</p>

<p>如果您的函数没有返回有用的值，请使其返回类型为<code>Future &lt;void&gt;</code>。</p>

<h3 id="toc_96">处理流</h3>

<p>当您需要从Stream获取值时，您有两个选择：</p>

<ul>
<li>使用async和异步for循环（<code>await for</code>）。 </li>
<li>使用Stream API，如<a href="https://www.dartlang.org/guides/libraries/library-tour#stream">库浏览</a>中所述。</li>
</ul>

<blockquote>
<p>使用await之前，请确保它使代码更清晰，并且您确实希望等待所有流的结果。例如，您通常不应该使用await for UI事件侦听器，因为UI框架会发送无穷无尽的事件流。</p>
</blockquote>

<p>异步for循环具有以下形式：</p>

<pre><code class="language-Dart">await for (varOrType identifier in expression) {
  // Executes each time the stream emits a value.
}
</code></pre>

<h2 id="toc_97">生成器</h2>

<p>您需要懒惰地生成sequence of values时，请考虑使用生成器函数。 Dart内置支持两种生成器：</p>

<ul>
<li>同步生成器：返回一个<a href="https://api.dartlang.org/stable/dart-core/Iterable-class.html">Iterable</a>对象。 </li>
<li>异步生成器：返回<a href="https://api.dartlang.org/stable/dart-core/Iterable-class.html">Stream</a>对象。</li>
</ul>

<p>要实现同步生成器函数，请将函数体标记为<code>sync*</code>，并使用<code>yield</code>语句来传递值：</p>

<pre><code class="language-Dart">Iterable&lt;int&gt; naturalsTo(int n) sync* {
  int k = 0;
  while (k &lt; n) yield k++;
}
</code></pre>

<p>要实现异步生成器函数，请将函数体标记为<code>async*</code>，并使用<code>yield</code>语句来传递值：</p>

<pre><code class="language-Dart">Stream&lt;int&gt; asynchronousNaturalsTo(int n) async* {
  int k = 0;
  while (k &lt; n) yield k++;
}
</code></pre>

<p>如果您的生成器是递归的，则可以使用yield *来提高其性能：</p>

<pre><code class="language-Dart">Iterable&lt;int&gt; naturalsDownFrom(int n) sync* {
  if (n &gt; 0) {
    yield n;
    yield* naturalsDownFrom(n - 1);
  }
}
</code></pre>

<p>有关生成器的更多信息，请参阅文章<a href="https://www.dartlang.org/articles/language/beyond-async">Dart语言异步支持：阶段2</a>。</p>

<h2 id="toc_98">Callable classes</h2>

<p>要允许像函数一样调用Dart类，请实现<code>call()</code>方法。</p>

<p>在下面的示例中，WannabeFunction类定义了一个call（）函数，它接受三个字符串并连接它们，用空格分隔每个字符串，并附加一个感叹号。单击“运行”按钮以执行代码。</p>

<pre><code class="language-Dart">class WannabeFunction {
  call(String a, String b, String c) =&gt; &#39;$a $b $c!&#39;;
}

main() {
  var wf = new WannabeFunction();
  var out = wf(&quot;Hi&quot;,&quot;there,&quot;,&quot;gang&quot;);
  print(&#39;$out&#39;);
}
</code></pre>

<p>有关处理函数类的更多信息，请参阅<a href="https://www.dartlang.org/articles/language/emulating-functions">在Dart中模拟函数</a>。</p>

<h2 id="toc_99">隔离</h2>

<p>大多数计算机，甚至在移动平台上，都有多核CPU。为了利用所有这些核心，开发人员传统上使用并发运行的共享内存线程。但是，共享状态并发容易出错，并且可能导致代码复杂化。</p>

<p>所有Dart代码都在隔离区内运行，而不是线程。每个隔离区都有自己的内存堆，确保不会从任何其他隔离区访问隔离区的状态。</p>

<p>有关更多信息，请参阅<a href="https://api.dartlang.org/stable/dart-isolate">dart：isolate库文档</a>。</p>

<h2 id="toc_100">类型定义</h2>

<p>在Dart中，函数是对象，就像字符串一样，数字是对象。 typedef或函数类型别名为函数类型提供了在声明字段和返回类型时可以使用的名称。当函数类型分配给变量时，typedef会保留类型信息。</p>

<p>请考虑以下代码，它不使用typedef：</p>

<pre><code class="language-Dart">class SortedCollection {
  Function compare;

  SortedCollection(int f(Object a, Object b)) {
    compare = f;
  }
}

// Initial, broken implementation.
int sort(Object a, Object b) =&gt; 0;

void main() {
  SortedCollection coll = SortedCollection(sort);

  // All we know is that compare is a function,
  // but what type of function?
  assert(coll.compare is Function);
}
</code></pre>

<p>将f分配给比较时，类型信息会丢失。 f的类型是（Object，Object）→int（其中→表示返回），但比较的类型是Function。如果我们将代码更改为使用显式名称并保留类型信息，则开发人员和工具都可以使用该信息。</p>

<pre><code class="language-Dart">typedef Compare = int Function(Object a, Object b);

class SortedCollection {
  Compare compare;

  SortedCollection(this.compare);
}

// Initial, broken implementation.
int sort(Object a, Object b) =&gt; 0;

void main() {
  SortedCollection coll = SortedCollection(sort);
  assert(coll.compare is Function);
  assert(coll.compare is Compare);
}
</code></pre>

<blockquote>
<p>注意：目前，typedef仅限于函数类型。我们希望这会改变。</p>
</blockquote>

<p>因为typedef只是别名，所以它们提供了一种检查任何函数类型的方法。例如：</p>

<pre><code class="language-Dart">typedef Compare&lt;T&gt; = int Function(T a, T b);

int sort(int a, int b) =&gt; a - b;

void main() {
  assert(sort is Compare&lt;int&gt;); // True!
}
</code></pre>

<h2 id="toc_101">元数据</h2>

<p>使用元数据提供有关代码的其他信息。元数据注释以字符@开头，后跟对编译时常量的引用（例如<code>deprecated</code>）或对常量构造函数的调用。</p>

<p>所有Dart代码都有两个注释：@deprecated和@override。有关使用@override的示例，请参阅扩展类。以下是使用@deprecated注释的示例：</p>

<pre><code class="language-Dart">class Television {
  /// _Deprecated: Use [turnOn] instead._
  @deprecated
  void activate() {
    turnOn();
  }

  /// Turns the TV&#39;s power on.
  void turnOn() {...}
}
</code></pre>

<p>您可以定义自己的元数据注释。这是一个定义带有两个参数的@todo注释的示例：</p>

<pre><code class="language-Dart">library todo;

class Todo {
  final String who;
  final String what;

  const Todo(this.who, this.what);
}
</code></pre>

<p>以下是使用@todo注释的示例：</p>

<pre><code class="language-Dart">import &#39;todo.dart&#39;;

@Todo(&#39;seth&#39;, &#39;make this do something&#39;)
void doSomething() {
  print(&#39;do something&#39;);
}
</code></pre>

<p>元数据可以出现在库，类，typedef，类型参数，构造函数，工厂，函数，字段，参数或变量声明之前以及导入或导出指令之前。您可以使用反射在运行时检索元数据。</p>

<h2 id="toc_102">注释</h2>

<p>Dart支持单行注释，多行注释和文档注释。</p>

<h3 id="toc_103">单行注释</h3>

<p>单行注释以//开头。 Dart编译器会忽略//和行尾之间的所有内容。</p>

<pre><code class="language-Dart">void main() {
  // TODO: refactor into an AbstractLlamaGreetingFactory?
  print(&#39;Welcome to my Llama farm!&#39;);
}
</code></pre>

<h3 id="toc_104">多行注释</h3>

<p>多行注释以<code>/*</code>开头，以<code>*/</code>结尾。 Dart编译器会忽略<code>/*</code>和<code>*/</code>之间的所有内容（除非注释是文档注释;请参阅下一节）。多行注释可以嵌套。</p>

<pre><code class="language-Dart">void main() {
  /*
   * This is a lot of work. Consider raising chickens.

  Llama larry = Llama();
  larry.feed();
  larry.exercise();
  larry.clean();
   */
}
</code></pre>

<h3 id="toc_105">文档注释</h3>

<p>文档注释是以<code>///</code>或<code>/**</code>开头的多行或单行注释。在连续行上使用<code>///</code>与多行文档注释具有相同的效果。</p>

<p>在文档注释中，Dart编译器忽略所有文本，除非它括在括号中。使用括号，您可以引用类，方法，字段，顶级变量，函数和参数。括号中的名称在已记录的程序元素的词法范围内得到解析。</p>

<p>以下是文档注释的示例，其中包含对其他类和参数的引用：</p>

<pre><code class="language-Dart">/// A domesticated South American camelid (Lama glama).
///
/// Andean cultures have used llamas as meat and pack
/// animals since pre-Hispanic times.
class Llama {
  String name;

  /// Feeds your llama [Food].
  ///
  /// The typical llama eats one bale of hay per week.
  void feed(Food food) {
    // ...
  }

  /// Exercises your llama with an [activity] for
  /// [timeLimit] minutes.
  void exercise(Activity activity, int timeLimit) {
    // ...
  }
}
</code></pre>

<p>在生成的文档中，[Food]成为Food类的API文档的链接。</p>

<p>要解析Dart代码并生成HTML文档，您可以使用SDK的<a href="https://github.com/dart-lang/dartdoc#dartdoc">文档生成工具</a>。有关生成的文档的示例，请参阅<a href="https://api.dartlang.org/stable">Dart API文档</a>。有关如何构建评论的建议，请参阅<a href="https://www.dartlang.org/guides/language/effective-dart/documentation">Dart Doc注释指南</a>。</p>

<h2 id="toc_106">总结</h2>

<p>本页概述了Dart语言中常用的功能。正在实施更多功能，但我们希望它们不会破坏现有代码。有关更多信息，请参阅<a href="https://www.dartlang.org/guides/language/spec">Dart语言规范</a>和<a href="https://www.dartlang.org/guides/language/effective-dart">Dffective Dart</a>。</p>

<p>要了解有关Dart核心库的更多信息，请参阅<a href="https://www.dartlang.org/guides/libraries/library-tour">Dart Libraries之旅</a>。</p>

<blockquote>
<p>本翻译为个人工成果,如需转发请注明出处.</p>
</blockquote>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-08-06T15:02:01+08:00" itemprop="datePublished">2018/8/6</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='mweb.html'>mweb</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15335389211853.html" itemprop="url">
		在CHD5.10.2 安装kylin2.4.0</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>最近一致有用户抱怨报表打开慢,我找了一下可能的解决方案,发现kylin比较适合我们的长今,今天打算安装试一下.</p>

<p>我们的测试环境为:</p>

<ul>
<li>CDH5.10.2 有hive impala kudu1.4 hbase</li>
</ul>

<p>下面开始安装</p>

<p>从官网下载安装包</p>

<pre><code class="language-bash">wget http://www.apache.org/dyn/closer.cgi/kylin/apache-kylin-2.4.0/apache-kylin-2.4.0-bin-cdh57.tar.gz
</code></pre>

<p>解压</p>

<pre><code class="language-bash">tar xzvf apache-kylin-2.4.0-bin-cdh57.tar.gz
</code></pre>

<p>到解压的bin目录执行环境检查<br/>
修改conf目录下的kylin.properies文件:</p>

<pre><code>#进入解压的目录
cd pache-kylin-2.4.0-bin-cdh57
export KYLIN_HOME=`pwd`
# kylin在hdfs的工作目录
kylin.env.hdfs-working-dir=/kylin
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-07-09T14:23:41+08:00" itemprop="datePublished">2018/7/9</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='mweb.html'>mweb</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15311174213941.html" itemprop="url">
		Centos7 安装kudu python客户端</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h3 id="toc_0">安装kudu的官方源</h3>

<pre><code class="language-bash">cd /etc/yum.repos.d/

wget http://archive.cloudera.com/kudu/redhat/7/x86_64/kudu/cloudera-kudu.repo

yum update

</code></pre>

<h3 id="toc_1">安装系统依赖</h3>

<pre><code class="language-bash">sudo yum install kudu                         # Base Kudu files
sudo yum install kudu-master                  # Kudu master init.d service script and default configuration
sudo yum install kudu-tserver                 # Kudu tablet server init.d service script and default configuration
sudo yum install kudu-client0                 # Kudu C++ client shared library
sudo yum install kudu-client-devel            # Kudu C++ client SDK
</code></pre>

<p>因此,只需要安装 kudu基础包 和客户端 及sdk即可</p>

<pre><code class="language-bash">yum install kudu kudu-client0 kudu-client-devel gcc -y
yum install gcc-c++ gcc -y
</code></pre>

<h3 id="toc_2">安装kudu_python客户端</h3>

<pre><code class="language-bash"># 这个依赖需要手动安装
pip install Cython
# 目前官方提供的C库以及我们适用的kudu是1.4版本,
# 所以不要安装python客户端的最新版本,我试过1.2版本是兼容的
pip install kudu_python==1.2
</code></pre>

<h3 id="toc_3">测试连接</h3>

<pre><code class="language-Python">import kudu
# 注意这里 host是kudu master的列表
client = kudu.connect(host=[&#39;192.168.3.32&#39;,&#39;192.168.3.31&#39;], port=7051)
# 获取表列表
a = client.list_tables()
# 打印列表
print a
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-05-25T09:38:29+08:00" itemprop="datePublished">2018/5/25</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='mweb.html'>mweb</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15272123098116.html" itemprop="url">
		关于cx_oracle TypeError: expecting string, unicode or buffer object 错误的解决</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>最近用cx_oracle插入数据的时候发现会报这个错误.一开始以为是数据的问题.费劲把插入报错的数据找到后.发现单条插入没有问题.所以怀疑是cx_oracle的bug.<br/>
一开始报错的版本是5.2.1,后来发现5.x都会报这个错.而6.x会报另外一个错误.这里暂且不提.</p>

<p>最终修复的方式是捕获错误尝试单条插入.下面的代码比较粗放仅供参考</p>

<pre><code>        for rows in insert_data.get_data_itera(5000, empty_string_as_None=empty_string_as_None):
            row_count = len(rows)
            try:
                target_cur.executemany(insert_sql, rows)
                target_conn.commit()
            except Exception,e:
                target_conn.rollback()
                logging.info(u&#39;批量插入报错,回滚并尝试单条插入&#39;)
                for row in rows:
                    target_cur.executemany(insert_sql,[row,])
                target_conn.commit()
            total_count += row_count
            logging.info(
                u&quot;插入 {row_num} 条数据,已插入{total_count}条记录&quot;.format(
                    row_num=str(row_count),
                    total_count=str(total_count)))
                    
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-05-24T08:04:36+08:00" itemprop="datePublished">2018/5/24</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='mweb.html'>mweb</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15271202760078.html" itemprop="url">
		Macbook mds 进程占用CPU问题</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>经查是Spotlight的索引进程.如果平时不用Spotlight 可以禁用掉.<br/>
禁用命令:</p>

<pre><code># 禁用
sudo mdutil -a -i off
# 启用
sudo mdutil -a -i on
</code></pre>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 
	
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    
<script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

</body>
</html>